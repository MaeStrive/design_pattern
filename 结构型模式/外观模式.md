@[toc]

# 结构型模式——外观模式

# 本质：封装交互、简化调用

## 一、定义

为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。在外观模式中，外部与一个子系统的通信可以通过一个统一的外观对象进行。**外观模式**又称**门面模式**。

## 二、问题描述

在计算机主机中，只需要按下主机的开机按钮，即可调用其他硬件设备和软件的启动方法，如内存的自检、CPU的运行、硬盘的读取、操作系统的载入等，如果某一过程方式错误则计算机启动失败。使用外观模式模拟该过程。

## 三、解决方案

外观模式:主机定义为外观角色，其中他有四个引用对象（内存，CPU,硬盘，操作系统），其中有一个启动方法，会调用它所有子系统对象的方法。

## 四、代码实现

1、(Facade)外观角色

在客户端可以调用这个角色的方法，在外观角色中可以知道相关的(一个或者多个)子系统的功能和责任。在正常情况下，他将所有从客户端发来的请求委派到相应的子系统中，传递给相应的子系统对象处理。

```java
package com.atmae.facade.newd;

/**
 * @Author: Mae
 * @Date: 2022/5/24
 * @Time: 8:23
 * @Description:
 */
public class Mainframe {

    private final Memory memory;
    private final HardDisk hardDisk;
    private final CPU cpu;
    private final OS os;

    public Mainframe() {
        memory = new Memory();
        hardDisk = new HardDisk();
        os = new OS();
        cpu = new CPU();
    }

    public void on() {
        memory.check();
        cpu.run();
        hardDisk.read();
        os.load();
        System.out.println("计算机启动成功！");
    }
}
```

2、(SubSystem)子系统角色

在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观仅仅是一个客户端而已。

```java
package com.atmae.facade.newd;

import java.util.Date;

/**
 * @Author: Mae
 * @Date: 2022/5/24
 * @Time: 8:23
 * @Description:
 */
public class Memory {
    public void check() {
        System.out.println("内存自检…………");
        if (System.currentTimeMillis() % 1024 == 0){
            try {
                throw new Exception("内存自检失败!");
            } catch (Exception e) {
                e.printStackTrace();
            }
        }else{
            System.out.println("内存自检成功！");
        }
    }
}
```

```java
package com.atmae.facade.newd;

/**
 * @Author: Mae
 * @Date: 2022/5/24
 * @Time: 8:23
 * @Description:
 */
public class HardDisk {
    public void read(){
        System.out.println("硬盘读取中…………");
        if (System.currentTimeMillis() % 1024 == 0){
            try {
                throw new Exception("硬盘读取失败!");
            } catch (Exception e) {
                e.printStackTrace();
            }
        }else{
            System.out.println("硬盘读取成功！");
        }
    }
}
```

```java
package com.atmae.facade.newd;

/**
 * @Author: Mae
 * @Date: 2022/5/24
 * @Time: 8:23
 * @Description:
 */
public class CPU {
    public void run(){
        System.out.println("内存启动中…………");
        if (System.currentTimeMillis() % 1024 == 0){
            try {
                throw new Exception("CPU启动失败!");
            } catch (Exception e) {
                e.printStackTrace();
            }
        }else{
            System.out.println("CPU启动成功！");
        }
    }
}
```

```java
package com.atmae.facade.newd;

/**
 * @Author: Mae
 * @Date: 2022/5/24
 * @Time: 8:24
 * @Description:
 */
public class OS {
    public void load() {
        System.out.println("操作系统载入中…………");
        if (System.currentTimeMillis() % 1024 == 0){
            try {
                throw new Exception("操作系统载入失败!");
            } catch (Exception e) {
                e.printStackTrace();
            }
        }else{
            System.out.println("操作系统载入成功！");
        }
    }
}
```

3、客户端

```java
package com.atmae.facade.newd;

/**
 * @Author: Mae
 * @Date: 2022/5/24
 * @Time: 8:33
 * @Description:
 */
public class Client {
    public static void main(String[] args) {
        Mainframe mainframe = new Mainframe();
        mainframe.on();
    }
}
```

## 五、UML图

![在这里插入图片描述](https://img-blog.csdnimg.cn/c0fb28d12f564032b92f9a3abc847a48.png#pic_center)


## 六、外观模式适用场景

- 当要为一个复杂子系统提供一个简单接口时可以使用外观模式。该接口可以满足大多数用户的需求，而且用户也可以越过外观类直接访问子系统
- 客户程序与多个子系统之间存在很大的依赖性。引入外观类将子系统与客户以及其他子系统解耦，可以挺高子系统的独立性和可移植性。
- 在层次化结构中，可以使用外观模式定义系统中每一层的入口，曾与曾之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。

## 七、总结

### 优点

- 对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。
- 实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用他的客户端，只需要调用外观类即可。
- 降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。
- 只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。

### 缺点

- 不能很好的限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。
- 在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了*开闭原则*。

## 八、与其他模式的关系

- **外观模式**为现有对象定义了一个新接口， **适配器模式**则会试图运用已有的接口。 适配器通常只封装一个对象， 外观通常会作用于整个对象子系统上。
- 当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用**抽象工厂模式**来代替外观。
- **享元模式**展示了如何生成大量的小型对象， 外观则展示了如何用一个对象来代表整个子系统。
- **外观**和**中介者**模式的职责类似： 它们都尝试在大量紧密耦合的类中组织起合作。
  - 外观为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。
  - 中介者将系统中组件的沟通行为中心化。 各组件只知道中介者对象， 无法直接相互交流。

- **外观**类通常可以转换为**单例模式**类， 因为在大部分情况下一个外观对象就足够了。
- **外观**与**代理模式**的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 代理与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与外观不同
