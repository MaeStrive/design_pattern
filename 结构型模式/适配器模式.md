@[toc]
# 结构型模式——适配器模式
## 一、定义
适配器模式是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。
## 二、问题
设计一个 仿生机器人 能学猫 也能学狗......
## 三、解决方案
**设配器**
将机器人定义为目标~~抽象类~~  接口(java没有多继承)。
猫和狗为适配者类。
再定义 两个 猫狗 适配器类 实现机器人接口 并且分别继承适配者类

## 四、代码实现
1、目标抽象类(接口)
客户要用到的特定领域的接口
```java
package com.atmae.adapter;

/**
 * @Author: Mae
 * @Date: 2022/5/11
 * @Time: 20:27
 * @Description:
 */
public interface Robot {
    void cry();
    void move();
}
```
2、适配者类
定义一个已经存在的接口，这个接口需要适配，其中包含了用户所需的业务方法
```java
package com.atmae.adapter;

/**
 * @Author: Mae
 * @Date: 2022/5/11
 * @Time: 20:28
 * @Description:
 */
public class Dog {
    public void bark() {
        System.out.println("汪汪汪");
    }

    public void run() {
        System.out.println("跑得快,长得帅");
    }
}
```
3、适配器类
需要对目标抽象类和适配者类进行适配。是适配器模式的核心。
```java
package com.atmae.adapter;

/**
 * @Author: Mae
 * @Date: 2022/5/11
 * @Time: 20:26
 * @Description:
 */
public class DogAdapter extends Dog implements Robot {
    @Override
    public void cry() {
        System.out.println("机器人模仿狗叫");
        super.bark();
    }

    @Override
    public void move() {
        System.out.println("机器人模仿狗跑");
        super.run();
    }
}
```
4、客户端
客户端代码只需通过接口与适配器交互即可， 无需与具体的适配器类耦合。 因此， 你可以向程序中添加新类型的适配器而无需修改已有代码。 这在适配者类被更改或替换时很有用： 你无需修改客户端代码就可以创建新的适配器
```java
package com.atmae.adapter;

/**
 * @Author: Mae
 * @Date: 2022/5/11
 * @Time: 20:32
 * @Description:
 */
public class Client {
    public static void main(String[] args) {
        Robot robot=new DogAdapter();
        robot.move();
    }
}

```
## 五、UML图
![在这里插入图片描述](https://img-blog.csdnimg.cn/049e111351754173b1349b9ca0ec974a.png#pic_center)

## 六、适配器模式适用场景
- 系统需要使用现有的类，而这些类的接口不符合系统的需要
- 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作

## 七、总结
### 优点
-  将目标类和适配者类解耦，通过引入适配器类重用现有的适配者类，而无需修改原有代码
- 增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类是透明的，而且提高了适配者的复用性
- 灵活性和扩展性非常好，通过使用配置文件，可以很方便的更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”
### 缺点
- 代码整体复杂度增加， 因为需要新增一系列接口和类。 有时直接更改适配者类使其与其他代码兼容会更简单。
## 八、与其他模式的关系
- 桥接模式通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， 适配器模式通常在已有程序中使用， 让相互不兼容的类能很好地合作。

- 适配器可以对已有对象的接口进行修改， 装饰模式则能在不改变对象接口的前提下强化对象功能。 此外， 装饰还支持递归组合， 适配器则无法实现。

- 适配器能为被封装对象提供不同的接口， 代理模式能为对象提供相同的接口， 装饰则能为对象提供加强的接口。

- 外观模式为现有对象定义了一个新接口， 适配器则会试图运用已有的接口。 适配器通常只封装一个对象， 外观通常会作用于整个对象子系统上。

- 桥接、 状态模式和策略模式 （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。  
