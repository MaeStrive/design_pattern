[TOC]

# 结构型模式——装饰模式

# 本质：动态组合，动态是手段，组合是目的

## 一、定义

动态地给一个对象增加一些额外的职责。

## 二、问题

设计一个图书管理系统，书籍类(Book)具有借书方法borrowBook()和还书方法returnBook()。现需要动态给书籍对象添加冻结方法freeze()和遗失方法lose()。使用装饰模式设计该系统。

## 三、解决方案

书籍类设计为抽象构件，再设计一个抽象装饰类，具体装饰类为四个方法，继承抽象装饰类。此外，再设计一个类似管理人类，它为具体构建类实现抽象构件。

## 四、代码实现

1、抽象构件(Component)

抽象构件定义了对象的接口，可以给这些对象动态增加方法。抽象构件是具体构件和抽象装饰类的共同父类。他声明了在具体构建类中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。

```java
package com.atmae.decorator.newd;

/**
 * @Author: Mae
 * @Date: 2022/5/22
 * @Time: 10:39
 * @Description:
 */
public interface Book {
    /**
     * 操作
     */
    void operation();
}
```

2、具体构件(ConcreteComponent)

具体构件定义了具体的构件对象，实现了在抽象构件中声明的方法，装饰类可以给它增加额外的方法。

```java
package com.atmae.decorator.newd;

/**
 * @Author: Mae
 * @Date: 2022/5/22
 * @Time: 10:40
 * @Description:
 */
public class Student implements Book {
    String name;

    public Student(String name) {
        this.name = name;
    }

    @Override
    public void operation() {
        System.out.println(this.name + "执行了以上操作");
        System.out.println("-------------------");

    }
}
```

3、抽象装饰类(Decorator)

抽象装饰类是抽象构件类的子类，用于给具体构件增加职责。但是具体职责在其子类中实现。它维护了一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。

```java
package com.atmae.decorator.newd;

/**
 * @Author: Mae
 * @Date: 2022/5/22
 * @Time: 10:42
 * @Description:
 */
public class Operation implements Book {
    private final Book book;

    public Operation(Book book) {
        this.book=book;
    }


    @Override
    public void operation() {
        this.book.operation();
    }
}
```

4、具体装饰类(ConcreteDecorator)

具体装饰类是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法以便扩充对象的行为。

```java
package com.atmae.decorator.newd;

/**
 * @Author: Mae
 * @Date: 2022/5/22
 * @Time: 10:45
 * @Description:
 */
public class BorrowBookOperation extends Operation {


    public BorrowBookOperation(Book book) {
        super(book);
    }

    @Override
    public void operation() {
        super.operation();
        System.out.println("\t归还图书");
    }
}



package com.atmae.decorator.newd;

/**
 * @Author: Mae
 * @Date: 2022/5/22
 * @Time: 10:45
 * @Description:
 */
public class FreezeBookOperation extends Operation {

    public FreezeBookOperation(Book book) {
        super(book);
    }

    @Override
    public void operation() {
        super.operation();
        System.out.println("\t冻结图书");
    }
}

package com.atmae.decorator.newd;

/**
 * @Author: Mae
 * @Date: 2022/5/22
 * @Time: 10:45
 * @Description:
 */
public class LoseBookOperation extends Operation {

    public LoseBookOperation(Book book) {
        super(book);
    }

    @Override
    public void operation() {
        super.operation();
        System.out.println("\t遗失图书");
    }
}


package com.atmae.decorator.newd;

/**
 * @Author: Mae
 * @Date: 2022/5/22
 * @Time: 10:45
 * @Description:
 */
public class ReturnBookOperation extends Operation {

    public ReturnBookOperation(Book book) {
        super(book);
    }

    @Override
    public void operation() {
        super.operation();
        System.out.println("\t归还图书");
    }
}

```

5、客户端

```java
package com.atmae.decorator.newd;

/**
 * @Author: Mae
 * @Date: 2022/5/22
 * @Time: 10:47
 * @Description:
 */
public class Client {
    public static void main(String[] args) {
        Book freezeBookOperation = new FreezeBookOperation(new ReturnBookOperation(new Student("张三")));
        freezeBookOperation.operation();
    }
}
```

## 五、UML图

![在这里插入图片描述](https://img-blog.csdnimg.cn/93d38952cb974a3ea3bbe06bf60f074f.png#pic_center)


## 六、装饰模式适用场景

- 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
- 需要动态地给一个对象添加功能，这些功能也可以动态地撤销。
- 当不能采用继承的方式对系统进行扩充或者采用继承不利于系统的扩展和维护时。不能采用继承的情况主要分为两类：第一类是一个系统中存在大量独立的扩展，为支持每一种组合将产生大量子类，使得子类数目呈爆炸性增长；第二类是因为类定义不能继承。

## 七、总结

### 优点

- 装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提高比继承更多的灵活性。
- 可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。
- *单一职责原则*。通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同的行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。
- *开闭原则*。具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新得具体构建类和具体装饰类，在使用时再对其进行组合，原有代码无须改变。

### 缺点

- 使用装饰模式进行系统设计时将产生很多小对象，这些对象得区别在于它们之间相互连接的方式有所不同，而不是他们的类或者属性值有所不同，同时还将产生许多具体装饰类，这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。
- 这些比继承更加灵活机动的特性，也同时意味装饰模式比继承更加容易出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐。

## 八、与其他模式的关系

- **适配器模式**可以对已有对象的接口进行修改， 装饰模式则能在不改变对象接口的前提下强化对象功能。 此外， 装饰还支持递归组合， 适配器则无法实现。

- **适配器模式**能为被封装对象提供*不同*的接口， **代理模式**能为对象提供*相同*的接口， **装饰模式**则能为对象提供*加强*的接口。

- **责任链模式**和**装饰模式**的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。

- 责任链的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种装饰可以在遵循基本接口的情况下扩展对象的行为。 此外， 装饰无法中断请求的传递。

- 组合模式和装饰的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。

- 装饰类似于组合， 但其只有一个子组件。 此外还有一个明显不同： 装饰为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了 “求和”。但是， 模式也可以相互合作： 你可以使用装饰来扩展组合树中特定对象的行为。

- 大量使用组合和装饰的设计通常可从对于**原型模式**的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。


- 装饰和代理有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于*组合*原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于代理通常自行管理其服务对象的生命周期， 而装饰的生成则总是由客户端进行控制。

### 装饰模式与策略模式
- **装饰**可让你更改对象的*外表*， **策略模式**则让你能够改变其*本质*。
装饰模式是递归调用，策略模式是一次调用
