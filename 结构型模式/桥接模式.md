@[toc]
# 结构型模式——桥接模式
# 本质：分离抽象和实现
## 一、定义
将抽象部分与它的实现部分分离，使他们都可以独立地变化。
## 二、问题
海尔(Haier)、TCL、海信(Hisense)都是家电制造商，他们生产电视机(Television)、空调(Air conditioner)、冰箱(Refrigeratory)。现需设计一个系统，描述这些家电制造商以及他们制造商以及他们所制造的电器。
## 三、解决方案

## 四、代码实现
1、抽象类(Abstract)
用于定义抽象的接口，他一般是抽象类不是接口，其中定义一个实现类接口类型的对象并可以维护该对象，他与实现类接口之间具有关联关系，它可以包含抽象的业务方法，还可以包含具体的业务方法。
```java
package com.atmae.bridgeConnection.new1;

/**
 * @Author: Mae
 * @Date: 2022/6/1
 * @Time: 12:53
 * @Description:
 */
public abstract class Manufacturer {
    protected HouseHold houseHold;

    public Manufacturer(HouseHold houseHold){
        this.houseHold=houseHold;
    }

    public abstract void produce();
}
```
2、扩充抽象类(RefinedAbstraction)
扩充由Abstraction定义的接口，通常情况下他不再是抽象类而是具体类，他实现了在Abstraction中定义的抽象业务方法，在RefinedAbstraction中可以调用在实现类接口中定义的业务方法。
```java
package com.atmae.bridgeConnection.new1;

/**
 * @Author: Mae
 * @Date: 2022/6/1
 * @Time: 12:56
 * @Description:
 */
public class Haier extends Manufacturer{
    public Haier(HouseHold houseHold) {
        super(houseHold);
    }

    @Override
    public void produce() {
        houseHold.show();
    }
}

package com.atmae.bridgeConnection.new1;

/**
 * @Author: Mae
 * @Date: 2022/6/1
 * @Time: 12:59
 * @Description:
 */
public class Hisence extends Manufacturer{
    public Hisence(HouseHold houseHold) {
        super(houseHold);
    }

    @Override
    public void produce() {
        houseHold.show();
    }
}

package com.atmae.bridgeConnection.new1;

/**
 * @Author: Mae
 * @Date: 2022/6/1
 * @Time: 12:58
 * @Description:
 */
public class TCL extends Manufacturer{
    public TCL(HouseHold houseHold) {
        super(houseHold);
    }

    @Override
    public void produce() {
        houseHold.show();
    }
}

```
3、实现类接口(Implementor)
定义实现类的接口，这个接口不一定要与Abstraction的接口完全一致，事实上这两个接口可以完全不同，一般地，Implementor只提供基本操作，而Abstraction定义的接口可以做更复杂的操作。Implementor接口对这些基本操作进行了定义，而具体实现交给其子类。通过关联关系，在Abstraction中不仅拥有自己的方法，还可以调用Implementor中定义的方法，使用关联关系来替代继承关系。
```java
package com.atmae.bridgeConnection.new1;

/**
 * @Author: Mae
 * @Date: 2022/6/1
 * @Time: 12:55
 * @Description:
 */
public interface HouseHold {
    public void show();
}
```
4、具体实现类(ConcreteImplementor)
实现Implementor接口并且具体实现它，在不同的ConcreteImplementor中提供基本操作的不同实现，在程序运行时，ConcreteImplementor对象将替换其父类对象，提供给客户端具体的业务操作方法。
```java
package com.atmae.bridgeConnection.new1;

/**
 * @Author: Mae
 * @Date: 2022/6/1
 * @Time: 13:00
 * @Description:
 */
public class AirConditioner implements HouseHold {
    @Override
    public void show() {
        System.out.println("制造空调");
    }
}

package com.atmae.bridgeConnection.new1;

/**
 * @Author: Mae
 * @Date: 2022/6/1
 * @Time: 13:00
 * @Description:
 */
public class Refrigeratory implements HouseHold {
    @Override
    public void show() {
        System.out.println("制造冰箱");
    }
}

package com.atmae.bridgeConnection.new1;

/**
 * @Author: Mae
 * @Date: 2022/6/1
 * @Time: 12:59
 * @Description:
 */
public class Television implements HouseHold{
    @Override
    public void show() {
        System.out.println("制造电视");
    }
}

```
## 五、UML图

![在这里插入图片描述](https://img-blog.csdnimg.cn/5a3d1833ade14a9f8bf1e25b24ffb9cb.png)

