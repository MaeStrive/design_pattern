@[toc]
# 结构型模式——桥接模式
# 本质：分离抽象和实现
## 一、定义
将抽象部分与它的实现部分分离，使他们都可以独立地变化。
## 二、问题
海尔(Haier)、TCL、海信(Hisense)都是家电制造商，他们生产电视机(Television)、空调(Air conditioner)、冰箱(Refrigeratory)。现需设计一个系统，描述这些家电制造商以及他们制造商以及他们所制造的电器。
## 三、解决方案
海尔、TCL、海信为扩充抽象类，他们都继承自一个抽象类，电视机、空调、冰箱为具体实现类，他们都实现一个实现类接口，抽象类中有一个实现类接口的引用。
## 四、代码实现
1、抽象类(Abstract)

用于定义抽象的接口，他一般是抽象类不是接口，其中定义一个实现类接口类型的对象并可以维护该对象，他与实现类接口之间具有关联关系，它可以包含抽象的业务方法，还可以包含具体的业务方法。
```java
package com.atmae.bridgeConnection.new1;

/**
 * @Author: Mae
 * @Date: 2022/6/1
 * @Time: 12:53
 * @Description:
 */
public abstract class Manufacturer {
    protected HouseHold houseHold;

    public Manufacturer(HouseHold houseHold){
        this.houseHold=houseHold;
    }

    public abstract void produce();
}
```
2、扩充抽象类(RefinedAbstraction)

扩充由Abstraction定义的接口，通常情况下他不再是抽象类而是具体类，他实现了在Abstraction中定义的抽象业务方法，在RefinedAbstraction中可以调用在实现类接口中定义的业务方法。
```java
package com.atmae.bridgeConnection.new1;

/**
 * @Author: Mae
 * @Date: 2022/6/1
 * @Time: 12:56
 * @Description:
 */
public class Haier extends Manufacturer{
    public Haier(HouseHold houseHold) {
        super(houseHold);
    }

    @Override
    public void produce() {
        houseHold.show();
    }
}

package com.atmae.bridgeConnection.new1;

/**
 * @Author: Mae
 * @Date: 2022/6/1
 * @Time: 12:59
 * @Description:
 */
public class Hisence extends Manufacturer{
    public Hisence(HouseHold houseHold) {
        super(houseHold);
    }

    @Override
    public void produce() {
        houseHold.show();
    }
}

package com.atmae.bridgeConnection.new1;

/**
 * @Author: Mae
 * @Date: 2022/6/1
 * @Time: 12:58
 * @Description:
 */
public class TCL extends Manufacturer{
    public TCL(HouseHold houseHold) {
        super(houseHold);
    }

    @Override
    public void produce() {
        houseHold.show();
    }
}

```
3、实现类接口(Implementor)

定义实现类的接口，这个接口不一定要与Abstraction的接口完全一致，事实上这两个接口可以完全不同，一般地，Implementor只提供基本操作，而Abstraction定义的接口可以做更复杂的操作。Implementor接口对这些基本操作进行了定义，而具体实现交给其子类。通过关联关系，在Abstraction中不仅拥有自己的方法，还可以调用Implementor中定义的方法，使用关联关系来替代继承关系。
```java
package com.atmae.bridgeConnection.new1;

/**
 * @Author: Mae
 * @Date: 2022/6/1
 * @Time: 12:55
 * @Description:
 */
public interface HouseHold {
    public void show();
}
```
4、具体实现类(ConcreteImplementor)

实现Implementor接口并且具体实现它，在不同的ConcreteImplementor中提供基本操作的不同实现，在程序运行时，ConcreteImplementor对象将替换其父类对象，提供给客户端具体的业务操作方法。
```java
package com.atmae.bridgeConnection.new1;

/**
 * @Author: Mae
 * @Date: 2022/6/1
 * @Time: 13:00
 * @Description:
 */
public class AirConditioner implements HouseHold {
    @Override
    public void show() {
        System.out.println("制造空调");
    }
}

package com.atmae.bridgeConnection.new1;

/**
 * @Author: Mae
 * @Date: 2022/6/1
 * @Time: 13:00
 * @Description:
 */
public class Refrigeratory implements HouseHold {
    @Override
    public void show() {
        System.out.println("制造冰箱");
    }
}

package com.atmae.bridgeConnection.new1;

/**
 * @Author: Mae
 * @Date: 2022/6/1
 * @Time: 12:59
 * @Description:
 */
public class Television implements HouseHold{
    @Override
    public void show() {
        System.out.println("制造电视");
    }
}

```
5、客户端
```java
package com.atmae.bridgeConnection.new1;

/**
 * @Author: Mae
 * @Date: 2022/6/1
 * @Time: 13:01
 * @Description:
 */
public class Client {
    public static void main(String[] args) {
        HouseHold airConditioner = new AirConditioner();
        Manufacturer haier = new Haier(airConditioner);
        haier.produce();
    }
}

```
## 五、UML图

![在这里插入图片描述](https://img-blog.csdnimg.cn/87f5e5f9858642f1b734750684b0bf7d.png#pic_center)


## 六、桥接模式适用场景
- 如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使他们在抽象建立一个关联关系。
- 抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合
- 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展
- 虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计需求需要独立管理这两者
- 对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。

## 七、总结
### 优点
- 分离抽象接口以及其实现部分。桥接模式使用“对象间的关联关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度变化。所谓抽象和实现沿着各自的维度变化，也就是说抽象和实现不再在同一个继承层次结构中，而是“子类化”他们，使他们各自都具有自己的子类，以便任意组合子类，从而获得多维度组合对象。
- 桥接模式有时类似多继承方案，但是多继承方案，但是多继承方案违背了类的单一职责原则(即一个类只有一个引起它发生变化的原因)，复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方案
- 桥接模式提高了系统的可扩展性，再两个变化维度中任意扩展一个维度，都不需要修改原有系统。
- 实现细节对客户透明，可以对用户隐藏实现细节。用户在使用时不需要关心实现，在抽象层通过聚合关联关系完成封装和对象的组合。
### 缺点
- 桥接模式的引入会增加系统的理解和设计维度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。
- 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。

## 八、与其他模式的关系
- 桥接模式通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， 适配器模式通常在已有程序中使用， 让相互不兼容的类能很好地合作。
- 桥接、 状态模式和策略模式 （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。
- 你可以将抽象工厂模式和桥接搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。
- 你可以结合使用生成器模式(建造者模式)和桥接模式： 主管类负责抽象工作， 各种不同的生成器负责实现工作。
