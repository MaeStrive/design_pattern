# 结构型模式——享元模式
# 本质：分离与共享
## 一、定义
享元模式是运用共享技术有效地支持大量细粒度对象的复用。系统只需要少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度
对象，因此又称为轻量级模式。
## 二、问题
在屏幕中显示一个文本文档，其中相同的字符串”java“共享同一个对象，而这些字符串的颜色和大小可以不同。使用享元模式设计。
## 三、解决方案
java共享同一个对象，则java字符串为一个内部状态；而颜色和大小可以不同，所有颜色和大小为外部状态。注意：外部状态要设置为一个实体类。抽象享元类的参数中含有这一实体类的引用。
## 四、代码实现
1、抽象享元类(Flyweight)
抽象享元类声明一个接口，通过它可以接受并作用与外部状态。在抽象享元类中定义了具体享元类公共的方法，这些方法可以像外界提供享元对象的内部数据(内部状态),同时也可以通过这些方法来
设置外部数据(外部状态)。
```java
package com.atmae.flyWeight;

/**
 * @Author: Mae
 * @Date: 2022/6/13
 * @Time: 16:54
 * @Description:
 */
public interface FlyWeight {
    void use(Font font);
}

```
2、具体享元类(ConcreteFlyweight)
具体享元类实现了抽象享元接口，其实例成为享元对象；在具体享元类中为内部状态提供了存储空间，由于具体享元对象必须是可以共享的，因此他存储的状态必须是内部的，即它独立存在于自己的
环境中。可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。
```java
package com.atmae.flyWeight;

/**
 * @Author: Mae
 * @Date: 2022/6/13
 * @Time: 16:54
 * @Description:
 */
public class ConcreteFlyWeight implements FlyWeight {
    private String str;


    public ConcreteFlyWeight(String str) {
        this.str = str;
    }

    @Override
    public void use(Font font) {
        System.out.println("这是一个字符串:" + this.str + ",大小：" + font.getShape() + ",颜色：" + font.getColor());
    }
}

```
3、非共享具体享元类(UnsharedConcreteFlyweight)
并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类则设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接被实例化创建；在某些享元模式的层次结构中，非共享具
体享元对象还可以将具体享元对象作为子节点。
```java
此案例中无非共享的具体享元类
```
4、享元工厂类(FlyweightFactory)
享元工厂类用于创建并管理享元对象；他针对抽象享元类编程，将各种类型的具体享元对象存储在一个享元池中，享元池一般设计为一个存储键值对的集合(也可以是其他类型),可以结合工厂模式的设
计；当用户请求一个具体享元对象时，享元工厂提供一个存储在享元池中已存在的实例或者创建一个新的实例(如果不存在的话),返回该新创建的实例并将其存储在享元池中。
```java
package com.atmae.flyWeight;

import java.util.HashMap;
import java.util.Hashtable;

/**
 * @Author: Mae
 * @Date: 2022/6/13
 * @Time: 16:59
 * @Description:
 */
public class FlyWeightFactory {
    private HashMap hashMap = new HashMap();

    public FlyWeightFactory() {
        FlyWeight flyWeight = new ConcreteFlyWeight("java");
        hashMap.put("java", flyWeight);
    }

    public FlyWeight getFlyWeight(String str) {
        if (!hashMap.containsKey(str)) {
            hashMap.put(str, new ConcreteFlyWeight(str));
        }
        return (FlyWeight) hashMap.get(str);
    }

    public Integer getCount() {
        return hashMap.size();
    }
}

```
5、外部状态类
```java
package com.atmae.flyWeight;

/**
 * @Author: Mae
 * @Date: 2022/6/13
 * @Time: 16:57
 * @Description:
 */
public class Font {
    private String shape;
    private String color;

    public Font(String shape, String color) {
        this.shape = shape;
        this.color = color;
    }

    public String getShape() {
        return shape;
    }

    public void setShape(String shape) {
        this.shape = shape;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }
}

```
6、客户端
```java
package com.atmae.flyWeight;

/**
 * @Author: Mae
 * @Date: 2022/6/13
 * @Time: 17:06
 * @Description:
 */
public class Client {
    public static void main(String[] args) {
        FlyWeightFactory flyWeightFactory = new FlyWeightFactory();
        FlyWeight java = flyWeightFactory.getFlyWeight("java");
        java.use(new Font("20px", "black"));
        System.out.println(flyWeightFactory.getCount());

        FlyWeight python = flyWeightFactory.getFlyWeight("python");
        python.use(new Font("18px", "red"));
        System.out.println(flyWeightFactory.getCount());
    }
}

```
## 五、UML图
![在这里插入图片描述](https://img-blog.csdnimg.cn/15ca2f8f86b24c91a7cc314cbd4550cd.png#pic_center)

## 六、享元模式的适用场景
- 一个系统有大量相同或者相似的对象，由于这些对象的大量使用，造成内存的大量耗费。
- 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。
- 使用享元模式需要维护一个存储享元对象的享元池，而这需要耗费资源，因此，应在多次重复使用享元对象时才值得使用享元模式。
## 七、总结
### 优点
- 享元模式的优点在于它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份。
- 享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境只保存一份
### 缺点
- 享元模式会使系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。
- 为了使对象可以共享，享元模式需要将享元的状态外部化，而读取外部状态使得运行时间变长。

## 八、与其他模式的关系
### 享元模式与简单工厂模式
享元模式与简单工厂模式连用，享元工厂通常提供一个静态的工厂方法用于返回享元对象，使用简单工厂模式来生产享元对象。
### 享元模式与单例模式
在一个系统中，通常只有一个享元工厂，因此享元类可以使用单例模式进行设计。
### 享元模式与组合模式
享元模式可以结合组合模式来生产复合享元模式，统一对享元对象设置外部状态。
