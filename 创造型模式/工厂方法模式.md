@[toc]
# 创造性模式——工工厂方法模式
# 本质：延迟到子类来选择实现
## 一、定义
在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生产具体的产品对象，这样做的目的时将产品类的实例化操作延迟到工厂类中完成
## 二、问题
宝马(BMW)工厂制造宝马汽车，奔驰(Benz)工厂制造奔驰汽车。
## 三、解决方案
宝马工厂和奔驰工厂实现同一个公共工厂接口，负责生产宝马和奔驰。宝马和奔驰也具有一个共有的父类。
## 四、代码实现
1、抽象产品(Product)
抽象产品定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的共同父类或接口。
```java
package com.atmae.factoryMethod.new1;

/**
 * @Author: Mae
 * @Date: 2022/6/1
 * @Time: 14:55
 * @Description:
 */
public interface Car {
    void show();
}

```
2、具体产品(ConcreteProduct)
具体产品实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，他们之间一一对应。
```java
package com.atmae.factoryMethod.new1;

/**
 * @Author: Mae
 * @Date: 2022/6/1
 * @Time: 14:56
 * @Description:
 */
public class BMW implements Car{
    @Override
    public void show() {
        System.out.println("宝马 500W");
    }
}

package com.atmae.factoryMethod.new1;

/**
 * @Author: Mae
 * @Date: 2022/6/1
 * @Time: 14:57
 * @Description:
 */
public class Benz implements Car{

    @Override
    public void show() {
        System.out.println("奔驰 490W");
    }
}

```
3、抽象工厂(Factory)
在抽象工厂类中，声明了工厂方法，用于返回一个产品。抽象工厂是工厂方法的核心，他与应用程序无关。任何在模式中创建对象的工厂类都必须实现该接口。
```java
package com.atmae.factoryMethod.new1;

/**
 * @Author: Mae
 * @Date: 2022/6/1
 * @Time: 14:55
 * @Description:
 */
public interface CarFactory {
     Car createCar();
}

```
4、具体工厂(ConcreteFactory)
具体工厂是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并由客户调用，返回一个具体产品类的实例。在具体工厂类中包含与应用程序密切相关的逻辑，并且接受应用程序调用以创建产品对象
```java
package com.atmae.factoryMethod.new1;

/**
 * @Author: Mae
 * @Date: 2022/6/1
 * @Time: 14:55
 * @Description:
 */
public class BMWFactory implements CarFactory{
    @Override
    public Car createCar() {
        return new BMW();
    }
}

package com.atmae.factoryMethod.new1;

/**
 * @Author: Mae
 * @Date: 2022/6/1
 * @Time: 14:57
 * @Description:
 */
public class BenzFactory implements CarFactory{
    @Override
    public Car createCar() {
        return new Benz();
    }
}

```

## 五、UML图
![在这里插入图片描述](https://img-blog.csdnimg.cn/fe44190a980647f39ccd9365c6f4ef71.png#pic_center)

## 六、工厂方法模式适用场景
- 一个类不知道他所需要的对象和类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。
- 一个类通过其子类来指定哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。
- 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无需关注哪一个工厂类创建产品子类，需要时再动态指定，可以将具体工厂类的类名存储在配置文件或数据库中。

## 七、总结
### 优点
- 在工厂方法中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要所需产品对应的工厂，无需关心创建细节，甚至无须知道具体产品类的类名。
- 基于工厂角色和产品角色的多态性设计时工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工程内部。工厂方法模式之所以被成为多态工厂模式，是因为所有具体的工厂类都具有同一抽象父类。
- 使用工厂方法模式的另一个优点时在系统中加入新产品时，无需修改抽象工厂抽象产品提供的接口，无需修改客户端，也无需修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样系统的可扩展性也变得非常号，完全符合“开闭原则”。
### 缺点
- 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编码和运行，会给系统带来额外的开销。
- 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均可以使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用DOM、反射等技术，增加了系统的实现难度。
## 八、与其他模式的关系
- 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制），随后演化为使用抽象工厂模式、原型模式或生成器模式（更灵活但更加复杂）。
- 抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。
- 你可以同时使用工厂方法和迭代器模式来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。
- 原型并不基于继承， 因此没有继承的缺点。另一方面，原型需要对被复制对象进行复杂的初始化。工厂方法基于继承，但是它不需要初始化步骤。
- 工厂方法是模板方法模式的一种特殊形式。同时，工厂方法可以作为一个大型模板方法中的一个步骤。
- **工厂方法模式与简单工厂模式在结构上的不同不是很明显。**
- **工厂方法类的核心是一个抽象工厂类，而简单工厂模式把核心放在一个具体类上。**
