# 创造性模式——抽象工厂模式
# 本质：选择产品族的实现
## 一、定义
提供一个创建一系列相关或相互依赖对象的接口，而不需指定他们具体的类。
## 二、问题
计算机包含内存、RAM、CPU等硬件设备，型号有 PC MAC，根据产品等级结构-产品族示意图使用抽象工厂创建
## 三、解决方案
产品等级：PC MAC  产品族：CPU RAM
## 四、代码实现
1、抽象工厂(AbstractFactory)
抽象工厂用于声明生成抽象产品的方法，在一个抽象工厂中可以定义一组方法，每一个方法对应一个等级结构。
```java
package com.atmae.abstractFactory.new2;

/**
 * @Author: Mae
 * @Date: 2022/5/14
 * @Time: 15:04
 * @Description:
 */
public interface AbstractFactory {
    public BaseRAM createRAM();
    public BaseCPU createCPU();
}

```
2、具体工厂(ConcreteFactory)
具体工厂实现了抽象工厂声明的生成抽象产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。
```java
package com.atmae.abstractFactory.new2;

/**
 * @Author: Mae
 * @Date: 2022/5/14
 * @Time: 15:08
 * @Description:
 */
public class MACFactory implements AbstractFactory{
    @Override
    public BaseRAM createRAM() {
        return new MACRAM();
    }

    @Override
    public BaseCPU createCPU() {
        return new MACCPU();
    }
}

```
```java
package com.atmae.abstractFactory.new2;

/**
 * @Author: Mae
 * @Date: 2022/5/14
 * @Time: 15:08
 * @Description:
 */
public class PCFactory implements AbstractFactory {
    @Override
    public BaseRAM createRAM() {
        return new PCRAM();
    }

    @Override
    public BaseCPU createCPU() {
        return new PCCPU();
    }
}

```
3、抽象产品(AbstractProduct)
抽象产品为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法。
```java
package com.atmae.abstractFactory.new2;

/**
 * @Author: Mae
 * @Date: 2022/5/14
 * @Time: 15:09
 * @Description:
 */
public abstract class BaseCPU {
    public abstract void show();
}

```
```java
package com.atmae.abstractFactory.new2;

/**
 * @Author: Mae
 * @Date: 2022/5/14
 * @Time: 15:09
 * @Description:
 */
public abstract class BaseRAM {
    public abstract void show();
}

```
4、具体产品(ConcreteProduct)
具体产品定义具体工厂生成的具体产品对象，实现抽象产品接口中定义的业务方法。
```java
package com.atmae.abstractFactory.new2;

/**
 * @Author: Mae
 * @Date: 2022/5/14
 * @Time: 15:12
 * @Description:
 */
public class PCCPU extends BaseCPU{
    @Override
    public void show() {
        System.out.println("我是 PC CPU");
    }
}

```
```java
package com.atmae.abstractFactory.new2;

/**
 * @Author: Mae
 * @Date: 2022/5/14
 * @Time: 15:12
 * @Description:
 */
public class PCRAM extends BaseRAM {
    @Override
    public void show() {
        System.out.println("我是PC RAM");
    }
}

```
```java
package com.atmae.abstractFactory.new2;

/**
 * @Author: Mae
 * @Date: 2022/5/14
 * @Time: 15:12
 * @Description:
 */
public class MACCPU extends BaseCPU{
    @Override
    public void show() {
        System.out.println("我是MAC CPU");
    }
}

```
```java
package com.atmae.abstractFactory.new2;

/**
 * @Author: Mae
 * @Date: 2022/5/14
 * @Time: 15:12
 * @Description:
 */
public class MACRAM extends BaseRAM{
    @Override
    public void show() {
        System.out.println("我是MAC RAM");
    }
}

```
5、客户端
```java
package com.atmae.abstractFactory.new2;

import org.xml.sax.SAXException;

import javax.xml.parsers.ParserConfigurationException;
import java.io.IOException;

/**
 * @Author: Mae
 * @Date: 2022/5/14
 * @Time: 15:19
 * @Description:
 */
public class Client {
    public static void main(String[] args){

        AbstractFactory macFactory=new MACFactory();
        BaseRAM ram = macFactory.createRAM();
        ram.show();
    }
}
```
## 四(2).扩展：XML+反射
使用XML+反射的好处：
用XML+反射方式创建产品，大大减少了代码量。(省略了抽象工厂类+具体工厂类)

xml配置类
```
package com.atmae.abstractFactory.new2;

import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.IOException;

/**
 * @Author: Mae
 * @Date: 2022/5/14
 * @Time: 15:28
 * @Description:
 */
public class DataUtil {
    private final static String SOURCE_NAME = "com.atmae.abstractFactory.new2";

    private static String createFactory() throws ParserConfigurationException, IOException, SAXException {
        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
        Document document = documentBuilder.parse("product.xml");
        NodeList products = document.getElementsByTagName("product");
        Node firstChild = products.item(0).getFirstChild();
        return firstChild.getNodeValue();
    }

    public static BaseCPU createCPU() throws ParserConfigurationException, IOException, SAXException, ClassNotFoundException, InstantiationException, IllegalAccessException {
        String factory = createFactory();
        return (BaseCPU) Class.forName(SOURCE_NAME + "." + factory + "CPU").newInstance();
    }

    public static BaseRAM createRAM() throws ParserConfigurationException, IOException, SAXException, ClassNotFoundException, InstantiationException, IllegalAccessException {
        String factory = createFactory();
        return (BaseRAM) Class.forName(SOURCE_NAME + "." + factory + "RAM").newInstance();
    }
}

```
XML配置
```xml
<?xml version="1.0" encoding="UTF-8" ?>
<products>
    <product>MAC</product>
</products>
```
客户端
```java
       BaseCPU cpu = DataUtil.createCPU();
       cpu.show();
```
## 五、UML图
![在这里插入图片描述](https://img-blog.csdnimg.cn/cfeaa94359d44c4f8cea83813201578a.png#pic_center)

## 六、抽象工厂模式使用场景
- 如果代码需要与多个不同系列的相关产品交互， 但是由于无法提前获取相关信息， 或者出于对未来扩展性的考虑， 你不希望代码基于产品的具体类进行构建， 在这种情况下， 你可以使用抽象工厂。
- 系统中有多于一个的产品族，而每次只使用其中一个产品族。可通过配置文件的方式使得用户可以动态改变产品族，也可以方便的增加产品族。
- 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，对于所有类型的工厂模式都是重要的。用户无需关心对象的创建过程，将对象的创建和使用解耦
- 属于同一个产品族的产品将在一起使用。
- 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。

## 七、总结
### 优点
- 可以确保同一工厂生成的产品相互匹配。
- 可以避免客户端和具体产品代码的耦合。
- 单一职责原则。 你可以将产品生成代码抽取到同一位置， 使得代码易于维护。
- 开闭原则。 增加新的具体工厂和产品无需修改已有代码。
### 缺点
- 由于采用该模式需要向应用中引入众多接口和类， 代码可能会比之前更加复杂。
- 不太容易扩展新的产品。
## 八、与其他模式的关系
- 抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法
- 当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用抽象工厂来代替外观模式。
- 抽象工厂、 建造者和原型都可以用单例模式来实现
    - 一个产品系列只需要一个实例就可以，所有可以把具体工厂实现成为单例。 
### 抽象工厂与工厂方法
工厂方法模式一般是针对单独的产品对象的创建，而抽象工厂模式注重产品族对象的创建，这是他们的区别。
如果把抽象工厂创建的产品族简化，这个产品族只有一个产品，那么抽象工厂与工厂方法是差不多的。抽象工厂可退化为工厂方法，工厂方法可退化为简单工厂。
