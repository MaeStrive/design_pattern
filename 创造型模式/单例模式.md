@[toc]

# 创造型模式——单例模式
# 本质：控制实例数目
## 一、定义

**单例模式**是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。

## 二、问题

使用单例模式加载配置文件并且仅产生一个对象。

## 三、解决方案

单例模式啊~~~

## 四、代码实现

1、单例类

**单例（Singleton） 类**声明了一个名为 `new­Instance/getInstance`(其实随便起啥都行，规范)获取实例的静态方法来返回其所属类的一个相同实例。

单例的构造函数必须对客户端 （Client） 代码隐藏。 调用 `获取实例`方法必须是获取单例对象的唯一方式。

```java
package com.atmae.singleton;

import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.IOException;

/**
 * @Author: Mae
 * @Date: 2022/5/18
 * @Time: 14:59
 * @Description:
 */
public class AppConfig {
    private static AppConfig appConfig;

    private AppConfig() {

    }


    public static AppConfig newInstance() throws ParserConfigurationException, IOException, SAXException, ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (appConfig == null) {
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder documentBuilder = factory.newDocumentBuilder();
            Document parse = documentBuilder.parse("appconfig.xml");
            NodeList bean = parse.getElementsByTagName("bean");
            String nodeValue = bean.item(0).getFirstChild().getNodeValue();
            appConfig = (AppConfig) Class.forName("com.atmae.singleton." + nodeValue).newInstance();
        }
        return appConfig;
    }
}
```

2、xml配置文件

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<config>
    <bean>AppConfig</bean>
</config>
```

## 五、UML图

![在这里插入图片描述](https://img-blog.csdnimg.cn/a91853ef352e46d4943170c1e4bc48cf.png#pic_center)

## 六、单例模式使用场景

- 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象
- 客户端调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。
-  可以更加严格地控制全局变量。

## 七、总结

### 优点

- 提供了唯一实例的受访控制。因为单例类封装了它的唯一实例，所有它可以严格控制客户如何以及何时访问它。
- 由于在内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁对象，单例模式无疑可以提供系统的性能
- 允许可变数目的实例，基于单例模式的拓展。

### 缺点

- 由于单例模式没有抽象层，因此单例类的扩展有很大的困难
- 单例类的职责过重，在一定程度上违背了”单一职责原则“。因为单例类既充当了工厂角色，提供了工厂方法，又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身功能融合到了一起。
- 滥用单例模式将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例模式，可能导致共享连接池对象的程序过多而出现连接池溢出。

## 八、与其他模式的关系

- 外观模式类通常可以转换为单例模式类， 因为在大部分情况下一个外观对象就足够了。
- 如果你能将对象的所有共享状态简化为一个享元对象， 那么享元模式就和单例类似了。 但这两个模式有两个根本性的不同。
  1. 只会有一个单例实体， 但是*享元*类可以有多个实体， 各实体的内在状态也可以不同。
  2. *单例*对象可以是可变的。 享元对象是不可变的。
- 抽象工厂模式、 创建者模式和原型模式都可以用单例来实现。

## 九、单例模式的扩展

**二者的构造方法都是私有**
### 1、饿汉式单例模式

饿汉式单例模式时在定义静态变量的时候实例化单例类，因此加载类的时候就已经创建好了对象

```java
private static AppConfig appConfig=new AppConfig();
```

### 2、懒汉式单例模式

懒汉式单例模式在第一次被引用时将自己实例化，在懒汉式单例类被加载时不会将自己实例化。

```java
if (appConfig == null) {
    appConfig=new AppConfig();
}
return appConfig;
```
