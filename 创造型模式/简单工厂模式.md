@[toc]

# 简单工厂模式

## 一、定义

简单工厂模式又称静态工厂方法模式，**它不属于23种设计模式**。
在简单工厂种可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。

## 二、场景分析

比如有一个水果工厂，你想要买水果，你无需知道 苹果，香蕉，橙子，是如何创建的，只需要知道水果名字即可得到水果。
技巧：
我们可以使用反射+xml 来创建对象，可以代替swtich或者if else 的语句。 XML不需要编译就可以运行，用起来太帅了，

## 三、代码实现

xml配置文件

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<fruits>
    <fruit>Orange</fruit>
</fruits>
```

1、工厂角色：
简单工厂的核心，负责实现创建所有实例的内部逻辑；工程类可以被外界世界调用，创建所需的产品对象；工厂类中提供一个静态的工厂方法，返回抽象产品类，所有具体的产品都是抽象产品的子类。

```java
package com.atmae.simpleFactory;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.IOException;

/**
 * @Author: Mae
 * @Date: 2022/3/16
 * @Time: 13:56
 * @Description:
 */
public class FruitFactory {
    /**
     * 水果工厂
     */
   public static Fruit createFruit(String fruitName) throws ParserConfigurationException, IOException, SAXException, ClassNotFoundException, InstantiationException, IllegalAccessException {
        return (Fruit) Class.forName("com.atmae.simpleFactory." + fruitName).newInstance();
    }
   
}
```

2、抽象产品角色：
是简单工厂模式所创建所有对象的父类，负责描述所有实例所共有的公共接口。

```java
package com.atmae.simpleFactory;

/**
 * @Author: Mae
 * @Date: 2022/3/16
 * @Time: 14:01
 * @Description:
 */
public abstract class Fruit {
    /**
     * 买水果
     */
    public abstract void buyFruit();
}
```

3、具体产品角色：
是简单工厂模式的创建目标，所有创建的对象都充当这个角色的某个具体产品类的实例。每个具体产品角色都结成抽象产品角色。

```java
package com.atmae.simpleFactory;

/**
 * @Author: Mae
 * @Date: 2022/3/16
 * @Time: 14:10
 * @Description:
 */
public class Apple extends Fruit{

    @Override
    public void buyFruit() {
        System.out.println("我是apple 苹果");
    }
}
```

```java
package com.atmae.simpleFactory;

/**
 * @Author: Mae
 * @Date: 2022/3/16
 * @Time: 14:10
 * @Description:
 */
public class Banana extends Fruit{
    @Override
    public void buyFruit() {
        System.out.println("我是香蕉Banana");
    }
}
```

```java
package com.atmae.simpleFactory;

/**
 * @Author: Mae
 * @Date: 2022/3/16
 * @Time: 14:11
 * @Description:
 */
public class Orange extends Fruit {
    @Override
    public void buyFruit() {
        System.out.println("我是橙子Orange");
    }
}
```

4、客户端

使用xml+反射 替换了 分支判断语句。

```java
package com.atmae.simpleFactory;

import org.xml.sax.SAXException;

import javax.xml.parsers.ParserConfigurationException;
import java.io.IOException;

/**
 * @Author: Mae
 * @Date: 2022/3/16
 * @Time: 14:11
 * @Description:
 */
public class Client {
    public static void main(String[] args) throws Exception {
        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
        Document parse = documentBuilder.parse("fruit.xml");
        String fruitName = parse.getElementsByTagName("fruit").item(0).getFirstChild().getNodeValue();
        Fruit fruit = FruitFactory.createFruit(fruitName);
        fruit.buyFruit();
    }
}
```

## 四、UML图

![在这里插入图片描述](https://img-blog.csdnimg.cn/7f545acf6cfe4ead8435431fda281c2a.png#pic_center)

## 五、简单工厂模式适用场景

- 工厂类负责创建的对象较少
- 客户端只知道传入工厂类的参数，对于如果创建对象并不关心。

## 六、总结

### 优点

- 工厂类含有必要的判断逻辑，可以决定什么时候创建哪个产品类，客户端可以免除直接创建产品对象的责任。实现对责任的分割，提供了专门的工厂类用于创建对象
- 客户端无需知道所创建具体产品类的类名，只需要知道具体产品类所对应的参数。
- 通过引入配置文件，可以在不修改任何客户端代码的情况更换和增加新的具体产品类，在一定程度上提高了程序的灵活性。

### 缺点

- 工厂类“权力”过于集中
- 工厂类不够灵活，难扩展
- 会增加系统中类的个数，在一定程度上增加了系统的复杂度
- 系统扩展困难，一旦添加新产品就不得不改变工厂逻辑，不符合**开放封闭**，不利于系统的扩展和维护
- 使用静态工厂方法，工厂角色无法形成基于继承的等级结构

**当你需要什么，只需要传入一个正确的参数，就可以获取所需对象，而无需知道创建细节。**

