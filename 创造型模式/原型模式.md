# 创建型模式——原型模式
# 本质：克隆生成对象
## 一、定义
通过给出一个原型对象来指明所要创建的对象类型，然后用复制这个原型对象的办法创建出更多的同类型对象
## 二、问题
设计一个客户类Customer，其中客户地址存储在地址类Address中，用浅克隆和深克隆分别实现Customer对象的复制并比较两种克隆模式的异同。
## 三、解决方案
0..0
## 四、代码实现
### 浅复制
1、Prototype(抽象原型类)
抽象原型类是定义具有克隆自己的方法接口，是所有具体原型类的公共父类，可以是抽象类，也可以是接口。

2、ConcretePrototype(具体原型类)
具体原型类实现具体的克隆方法,在克隆方法中返回自己的一个克隆对象。
```java
package com.atmae.prototype.newd;

import java.io.Serializable;

/**
 * @Author: Mae
 * @Date: 2022/6/8
 * @Time: 10:43
 * @Description:
 */
public class Customer implements Cloneable {

    private String name;
    private Integer age;
    private Address address;

    public Customer(String name, Integer age, Address address) {
        this.name = name;
        this.age = age;
        this.address = address;
    }


    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }


}

```
引用对象
```java

package com.atmae.prototype.newd;

/**
 * @Author: Mae
 * @Date: 2022/6/8
 * @Time: 10:44
 * @Description:
 */
public class Address implements Cloneable{

    private String province;
    private String city;
    private String district;

    public Address(String province, String city, String district) {
        this.province = province;
        this.city = city;
        this.district = district;
    }

    public String getProvince() {
        return province;
    }

    public void setProvince(String province) {
        this.province = province;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public String getDistrict() {
        return district;
    }

    public void setDistrict(String district) {
        this.district = district;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}

```
3、Client(客户端)
客户类让一个原型克隆自身，从而创建要给新的对象。在客户端类中只需要直接实例化或通过工厂方法等方式创建一个对象，再通过调用该对象的克隆方法复制得到多个相同的对象。
```java
package com.atmae.prototype.newd;

/**
 * @Author: Mae
 * @Date: 2022/6/8
 * @Time: 10:48
 * @Description:
 */
public class Client {
    public static void main(String[] args) throws CloneNotSupportedException {
        Address address = new Address("山东省", "泰安市", "泰山区");
        Customer customer = new Customer("王浩", 20, address);
        Customer customer2 = (Customer) customer.clone();
        System.out.println(customer2.getAddress().getProvince());
        System.out.println("--------------------------------------");
        customer2.getAddress().setProvince("广西省");
        System.out.println(customer2.getAddress().getProvince());
        System.out.println(customer.getAddress().getProvince());
    }
}

```
**结果**
```
山东省
--------------------------------------
广西省
广西省
```
### 深复制
修改具体原型类的克隆方法：
```java
    @Override
    protected Object clone() throws CloneNotSupportedException {
        Customer customer = (Customer) super.clone();
        Address address = (Address) this.address.clone();
        customer.setAddress(address);
        return customer;
    }
```
**结果**
```
山东省
--------------------------------------
广西省
山东省
```
### 总结
浅复制，克隆对象中的引用对象指向的是用一个地址，即修改了一个，其他的将会改变。
深复制，克隆对象中的引用对象指向的是不用地址，即修改了一个，其他的不会改变。
## 五、UML图
![在这里插入图片描述](https://img-blog.csdnimg.cn/e8300dd64fca44f98944bb1a5819a76e.png#pic_center)

## 六、总结
### 优点
- 当创建新的对象实例时较为复杂时，使用原型模式可以简化对象的创建过程，通过一个已有实例可以提高新实例的创建效率
- 可以动态增加或减少产品类。由于创建产品类实例的方法是产品类(具体原型类)内部具有的，因此增加新产品对整个结构没有影响。在原型模式中提高了抽象原型类，在客户端可以针对抽象原型
 类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响。
- 原型模式提供了简化的创建结构。工厂方法模式常常需要有一个与产品类等级结构相同的等级结构，而原型结构不是这样，原型模式中的产品的复制是通过封装再原型类中的clone()方法实现的
 无需专门的工厂类创建产品。
- 可以使用深克隆的方式保存对象的状态。
### 缺点
- 需要为每个类配备一个克隆方法，而且这个克隆方法需要对类的功能进行通篇考虑，这对全新的类来说不是很难，但对已有类进行改造时，不一定是件容易事，必须修改其源代码，违背了
 "开闭原则"
- 在实现深克隆时需要编写较复杂的代码。
## 七、原型模式使用场景
- 创建新对象的成本较大。
- 如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占内存不大的时候，也可以使用原型模式配合备忘录模式类应用
- 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更方便。
## 八、与其他模式的关系
### 原型模式和工厂模式
虽然原型引入完全可以达到工厂模式的郊果；而且，用起来甚至比工厂模式更方便、灵活。对于工厂模式与原形模式在功能上的这点巧合，
也许是因为本来工厂模式和原型模式都是创建型模式（三种类型，行为、结构），这样，他们的基本功能都能生成对象，因而使得原型模式在功能上可以代替工厂模式。

## 九、扩展
### 浅克隆
被复制对象的所有普通成员变量都具有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。
浅克隆仅仅复制所考虑的对象，而不复制它所引用的成员对象，也就是其中的成员对象并不复制。
### 深克隆
被复制对象的所有普通成员变量也都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不是原有的那些被引用的对象。
深克隆把要复制的对象所引用的对象都复制了一遍。
