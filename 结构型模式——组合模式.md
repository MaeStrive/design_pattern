@[toc]

# 结构型模式——组合模式

## 一、定义

**组合模式**是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。

组合多个对象形成树形结构以表示“部分——整体”的结构层次。组合模式对单个对象(即叶子对象)和组合对象(即容器对象)的使用具有一致性。组合模式又称为“部分整体模式”，将对象组织到树结构中，可以用来描述整体和部分的关系。

## 二、问题

在水果盘中有一些水果，如苹果、香蕉、梨，大水果盘还有小水果盘，需要吃盘中的水果。用组合模式模拟该场景？

## 三、解决方案

定义一个抽象构件，再定义容器构件和叶子构件，各个水果就是叶子构件，水果盘为容器构件。叶子构件和水果构件都继承于抽象构件。

## 四、代码实现

1、抽象构件(Component)

抽象部件可以是接口也可以是抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构建的方法，如增加子构件，删除子构件，获取子构建等。

```java
package com.atmae.composite;

/**
 * @Author: Mae
 * @Date: 2022/5/18
 * @Time: 13:23
 * @Description:
 */
public abstract class Component {
    public abstract void add(Component component);

    public abstract void remove(Component component) throws Exception;

    public abstract void eat() throws Exception;
}

```

2、叶子构件(Leaf)

叶子构件在组合构件中表示叶子节点对象，叶子节点没有子节点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构建的方法，可以通过异常等方式进行处理。

```java
package com.atmae.composite;

/**
 * @Author: Mae
 * @Date: 2022/5/18
 * @Time: 13:27
 * @Description:
 */
public class Banana extends Component{
    @Override
    public void add(Component component) {
        throw new RuntimeException("it's leaf!not add!");

    }

    @Override
    public void remove(Component component) throws RuntimeException {
        throw new RuntimeException("it’s leaf!not remove!");
    }

    @Override
    public void eat() throws RuntimeException {
        System.out.println("eat banana!~~");
    }
}
```

```java
package com.atmae.composite;

/**
 * @Author: Mae
 * @Date: 2022/5/18
 * @Time: 13:27
 * @Description:
 */
public class Apple extends Component{
    @Override
    public void add(Component component) {
        throw new RuntimeException("it's leaf!not eat!");

    }

    @Override
    public void remove(Component component) throws RuntimeException {
        throw new RuntimeException("it’s leaf!not remove!");
    }

    @Override
    public void eat() throws RuntimeException {
        System.out.println("eat apple!!!");
    }
}

```

```java
package com.atmae.composite;

/**
 * @Author: Mae
 * @Date: 2022/5/18
 * @Time: 13:27
 * @Description:
 */
public class Banana extends Component{
    @Override
    public void add(Component component) {
        throw new RuntimeException("it's leaf!not add!");

    }

    @Override
    public void remove(Component component) throws RuntimeException {
        throw new RuntimeException("it’s leaf!not remove!");
    }

    @Override
    public void eat() throws RuntimeException {
        System.out.println("eat banana!~~");
    }
}
```

3、容器构件

容器构件在组合模式中表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为，包括那些访问及管理子构建的方法，在其业务方法中可以递归调用其子节点的业务方法。

```java
package com.atmae.composite;

import java.util.ArrayList;
import java.util.List;

/**
 * @Author: Mae
 * @Date: 2022/5/18
 * @Time: 13:25
 * @Description:
 */
public class Plant extends Component {
    private List<Component> components = new ArrayList<>();

    @Override
    public void add(Component component) {
        components.add(component);
    }

    @Override
    public void remove(Component component) {
        components.remove(component);
    }

    @Override
    public void eat() throws Exception {
        for (Component component : components) {
            component.eat();
        }
    }
}

```

4、客户端

客户端可以通过抽象构件接口访问和控制组合构件中的对象

```java
package com.atmae.composite;

/**
 * @Author: Mae
 * @Date: 2022/5/18
 * @Time: 13:30
 * @Description:
 */
public class Client {
    public static void main(String[] args) {
        Apple apple=new Apple();
        Pear pear=new Pear();
        Pear pear1=new Pear();
        Banana banana=new Banana();
        Banana banana1=new Banana();
        Plant plant=new Plant();
        plant.add(apple);
        plant.add(pear);
        plant.add(pear1);
        Plant plant1=new Plant();
        plant1.add(banana);
        plant1.add(banana1);
        plant1.add(plant);
        try {
            plant1.eat();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```



## 五、UML图

![在这里插入图片描述](https://img-blog.csdnimg.cn/86b113be82e04205bbbc0fd843d2bcd1.png#pic_center)

## 六、组合模式适用场景

- 模式需要一个对象的整体或部分层次，在具有整体和部分的层次结构中，希望通过一种方式忽略整体和部分的差异，可以一致地对待他们。
- 让客户能够忽略不同对象层次地变化，客户端可以针对抽象接口的编程，而无需关心对象层次结构的细节。
- 对象的结构是动态的并且复杂程度不一样，但客户端需要一致地处理他们。

## 七、总结

### 优点

- 组合模式可以清楚地定义分层次地复杂对象，表示对象的全部或部分层次，使得增加新构件也更容易，因为它让客户端忽略了层次的差异，而他的构件又是动态的，提供了对象管理的灵活接口，因此组合模式可以方便地对层次结构进行控制。
- 客户端的调用简单，客户端可以一致地使用组合结构或者其中单个对象，用户就不必关系自己处理的是单个对象还是整个组合结构，简化了客户端代码。
- 定义了包含叶子对象和容器对象地类层次结构，叶子对象可以被组合成更复杂地容器对象，而这个容器对象又可以被组合，这样又不断递归下去，可以形成更复杂的树形结构。
- 更容易在组合体内加入对象构件，客户端不必因为加入了新的对象构件而更改原有代码。
-  你可以利用多态和递归机制更方便地使用复杂树结构。
-  **开闭原则**。 无需更改现有代码， 你就可以在应用中添加新元素， 使其成为对象树的一部分。

### 缺点

- 使设计变得更加抽象，对象地业务规则如果很复杂，则实现组合模式具有很大挑战性，而且不是所有的方法都与叶子对象子类有关联。
- 增加新构件时可能产生一些问题，很难对容器中的构建类型进行限制。有时候我们希望一个容器中只能由某些特定类型的对象，使用组合模式时，不能依赖类型系统来施加这些约束，因为他们都来自于相同的抽象层，在这种情况下，必须通过在运行时进行类型检查来实现，这个实现过程较为复杂。
- 对于功能差异较大的类， 提供公共接口或许会有困难。 在特定情况下， 你需要过度一般化组件接口， 使其变得令人难以理解。

## 八、与其他模式的关系

- **桥接模式**、 **状态模式**和**策略模式**（在某种程度上包括**适配器模式**） 模式的接口非常相似。 实际上， 它们都基于**组合模式**——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。

- 你可以在创建复杂组合树时使用建造者模式， 因为这可使其构造步骤以递归的方式运行。

- **责任链模式**通常和组合模式结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。

- 你可以使用**迭代器模式**来遍历组合树。

- 你可以使用**访问者模式**对整个组合树执行操作。

- 你可以使用**享元模式**实现组合树的共享叶节点以节省内存。

- **组合和装饰模式**的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。

  *装饰*类似于*组合*， 但其只有一个子组件。 此外还有一个明显不同： *装饰*为被封装对象添加了额外的职责， *组合*仅对其子节点的结果进行了 “求和”。

  但是， 模式也可以相互合作： 你可以使用*装饰*来扩展*组合*树中特定对象的行为。

- 大量使用组合和装饰的设计通常可从对于原型模式的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。

## 九、组合模式扩展

### 透明组合模式和安全组合模式

#### 1、透明组合模式

在透明组合模式中，抽象构件(Component)中声明了所有用于管理成员对象的方法，包括add，remove等，这样做的好处是确保所有的构件类都有相同的接口，在客户端看来，叶子节点与容器对象所提供的方法是一致的，客户端可以相同的对待所有对象。

缺点是**不够安全**，因为叶子对象和容器对象在本质上是有去别的。叶子对象不可能有下一层次的对象，即不可能包含成员对象，因此为其塔公add，remove等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用了这些方法可能会出错。

#### 2、安全组合模式

在安全组合模式中，抽象构件(Component)没有声明任何用于管理成员对象的方法，而是在容器构件(Composite)类中声明这些用于管理成员对象的方法。这样做法是安全的，因为根本不向叶子对象提供这些管理成员的对象的方法，对于叶子对象，客户端不可能调用到这些方法。*即编译时检查。*

安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件中定义，因为客户端不能完全针对抽象编程，并一致的使用叶子构件和抽象构件。

在实际使用中，安全组合模式的相对使用的频率更高

