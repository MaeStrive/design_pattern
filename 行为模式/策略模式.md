@[toc]

# 行为型模式——策略模式

# 本质：分离算法，选择实现

## 一、定义

定义一系列算法，将每一个算法封装起来，并让他们可以相互替换。策略模式让算法独立于使用它的客户而变化。

## 二、问题

设计一个网上书店，该系统中所有的计算机类图书每本有10%的折扣，所有语言类的图书每本有2元的折扣，小说类图书每100元有10元的折扣。使用策略模式设计该系统

## 三、解决方案

每种图书的折扣算法都可以看做是一个具体的策略类，他们都实现一个抽象的策略类。定义一个环境类，它用于抽象策略类的引用。

## 四、代码实现

1、环境类

环境类是使用算法的角色，它在解决某个问题(即实现某个方法)时可以采用多种策略。在环境类中维护一个对抽象策略类的引用实例，用于定义所采用的策略

```java
package com.atmae.strategy.newd;

/**
 * @Author: Mae
 * @Date: 2022/5/23
 * @Time: 10:15
 * @Description:
 */
public class Context {
    private Strategy strategy;

    public Context(Strategy strategy) {
        this.strategy = strategy;
    }

    public void shop() {
        this.strategy.shop();
    }
}
```

2、抽象策略类

抽象策略类为所支持算法声明了抽象方法，是所有策略类的父类，它可以是抽象类，也可以是接口。环境类使用在其中声明的方法调用在具体策略类中实现的算法

```java
package com.atmae.strategy.newd;

/**
 * @Author: Mae
 * @Date: 2022/5/23
 * @Time: 10:15
 * @Description:
 */
public interface Strategy {
    void shop();
}
```

3、具体策略类

具体策略类实现了在抽象策略类中定义的算法，在运行时，具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务逻辑

```java
package com.atmae.strategy.newd;

/**
 * @Author: Mae
 * @Date: 2022/5/23
 * @Time: 10:28
 * @Description:
 */
public class ComputerBook implements Strategy {
    public Double price;

    public ComputerBook(Double price) {
        this.price = price;
    }


    @Override
    public void shop() {
        System.out.println("此书的最终价格:" + (this.price - this.price * 0.1));
    }
}
```

```java
package com.atmae.strategy.newd;

/**
 * @Author: Mae
 * @Date: 2022/5/23
 * @Time: 10:28
 * @Description:
 */
public class LanguageBook implements Strategy {
    public Double price;

    public LanguageBook(Double price) {
        this.price = price;
    }


    @Override
    public void shop() {
        System.out.println("此书的最终价格:" + (this.price - 2));
    }
}
```

```java
package com.atmae.strategy.newd;

/**
 * @Author: Mae
 * @Date: 2022/5/23
 * @Time: 10:28
 * @Description:
 */
public class NovelBook implements Strategy {
    public Double price;

    public NovelBook(Double price) {
        this.price = price;
    }


    @Override
    public void shop() {
        System.out.println("此书的最终价格:" + (this.price - this.price.intValue() / 100 * 10));
    }
}
```

## 五、UML图

![在这里插入图片描述](https://img-blog.csdnimg.cn/1b14c28252464e50bc25018d8b0b268d.png#pic_center)

## 六、总结

### 优点

- 符合*开放封闭*原则，用户可以在不修改原有系统的基础上选择算法和行为，也可以灵活的增加新的算法和行为
- 提供了管理相关算法族的办法。策略类的等级结构定义了一个算法或行为族，恰当使用继承可以把公共的代码移到父类里面，从而避免重复的代码。
- 提供了可以替换继承关系的办法。继承可以处理多种算法或行为，如果不使用策略模式，那么使用算法或行为的环境类就可能会有一些子类，每一个子类提供不同的算法或行为。但是，这样一来算法或行为的使用就和算法或行为本身混在一起，不符合*单一职责原则*，决定哪一种算法或采取哪一种行为的逻辑就和算法本身的逻辑混合在一起，从而不可能再独立演化，而且使用继承无法实现算法或行为的动态改变。
- 使用策略模式可以避免使用多重条件转移语句。多重转移语句不易维护，他把采取哪一种算法或者采用哪一种行为的逻辑混合在一起，统统列在一个多重条件转移语句里面，比使用继承的办法还要原始和落后。

### 缺点

- 客户端必须知道所有策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道所有的算法或行为的情况
- 策略模式将造成许多策略类和对象，可以通过适用享元模式在一定程度上减少对象的数量

## 七、策略模式适用场景

- 如果在一个系统里面有很多类，它们之间的区别仅仅在于他们的行为，那么适用策略模式可以动态地让一个对象在许多行为中选择一种行为。

- 一个系统需要动态地选择在某几种算法中选择一种，那么可以将这些算法封装到一个个的具体算法类里面，而这些具体算法类都是一个抽象算法类的子类。换言之，这些具体类均有统一的接口，由于多态性原则，客户端可以选择使用任何一个具体算法类，并只需要维持一个数据类型是抽象算法类的对象
- 如果一个对象有很多行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。此时使用策略模式，把这些行为转移到相应的具体策略类里面，就可以避免使用难以维护的多重条件选择语句，并且体现面向对象的设计思想
- 不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法和相关的数据结构，提高算法的保密性和安全性。

## 八、与其他模式的关系

- **桥接模式**、 **状态模式**和**策略模式** （在某种程度上包括**适配器模式**） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。
-  **命令模式**和**策略模式**看上去很像， 因为两者都能通过某些行为来参数化对象。 但是， 它们的意图有非常大的不同。
  - 你可以使用命令来将任何操作转换为对象。 操作的参数将成为对象的成员变量。 你可以通过转换来延迟操作的执行、 将操作放入队列、 保存历史命令或者向远程服务发送命令等。
  - 另一方面， 策略通常可用于描述完成某件事的不同方式， 让你能够在同一个上下文类中切换算法。

- **装饰模式**可让你更改对象的外表， **策略模式**则让你能够改变其本质。
- **模板方法模式**基于*继承机制*： 它允许你通过扩展子类中的部分内容来改变部分算法。 策略基于组合机制： 你可以通过对相应行为提供不同的策略来改变对象的部分行为。 模板方法在类层次上运作， 因此它是静态的。 策略在对象层次上运作， 因此允许在运行时切换行为。
- **状态**可被视为**策略**的扩展。 两者都基于组合机制： 它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为。 策略使得这些对象相互之间完全独立， 它们不知道其他对象的存在。 但状态模式没有限制具体状态之间的依赖， 且允许它们自行改变在不同情景下的状态。
**装饰模式与策略模式**
- 策略模式改变的是对象的内核，装饰模式改变的是对象的外壳
- 策略模式是一层调用，装饰模式是递归调用
- 可以有机结合
