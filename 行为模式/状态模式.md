# 行为模式——状态模式
# 本质：根据状态来分离和选择行为。状态模式是状态驱动，由上下文负责
## 一、定义
允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。
## 二、问题
某纸牌游戏软件中，人物角色有入门级Primary、熟练级Secondary、高手级Professional、骨灰级Final，角色等级与其积分对应，游戏胜利获得积分，失败扣除积分。入门级具有最简单的功能play，
熟练级别在入门级别基础上增加了doubleScore，高手级别在熟练级别基础上增加了changeCards，骨灰级在高手级别上增加了peekCards。
## 三、解决方案
状态模式，有四个具体状态类，实现一个抽象状态类，四个具体状态类中的方法有所不同。
## 四、代码实现
1、环境类(Context)
环境类又称上下文类，他是拥有状态的对象，但是由于其状态村子多样性且在不同状态下对象的行为有所不同，因此将状态独立出去形成单独的状态类。在环境类中维护一个抽象状态类State的实例，
这个实例定义当前状态，在具体实现时，他是一个State子类的对象，可以定义初始状态。
```java
package com.atmae.state.newd;

/**
 * @Author: Mae
 * @Date: 2022/6/5
 * @Time: 15:33
 * @Description:
 */
public class Context {
    private State state;

    public int score = 0;

    public Context() {
        this.state = new PrimaryState();
    }

    public void request() {
        this.state.handle(this);
    }

    public void setState(State state) {
        this.state = state;
    }

}

```
2、抽象状态类(State)
抽象状态类用于定义一个接口以封装与环境类的一个特定状态相关的行为，在抽象状态类中声明了各种不同状态对应的方法，而在其子类中实现了这些方法，由于不同状态下对象的行为可能不同，因
此在不同子类中方法的实现可能存在不同，相同的方法可以写在抽象状态类中。
```java
package com.atmae.state.newd;

/**
 * @Author: Mae
 * @Date: 2022/6/5
 * @Time: 15:34
 * @Description:
 */
public abstract class State {



    public abstract void handle(Context context);

}

```
3、具体状态类(ConcreteState)
具体状态类是抽象状态类的子类，每一个子类实现一个与环境类的一个状态相关的的行为，每一个具体状态类对应环境的一个具体状态，不同的具体状态类其行为有所不同。
```java
package com.atmae.state.newd;

/**
 * @Author: Mae
 * @Date: 2022/6/5
 * @Time: 15:35
 * @Description:
 */
public class PrimaryState extends State {


    @Override
    public void handle(Context context) {
        if (context.score >= 100) {
            context.setState(new SecondaryState());
            context.request();
        }else{
            System.out.println("只有简单的play功能");
        }
    }
}



package com.atmae.state.newd;

/**
 * @Author: Mae
 * @Date: 2022/6/5
 * @Time: 15:36
 * @Description:
 */
public class SecondaryState extends State {


    @Override
    public void handle(Context context) {
        if (context.score >= 250) {
            context.setState(new ProfessionalState());
            context.request();

        } else {
            System.out.println("解锁分数加倍功能 doubleScore");
        }
    }
}



package com.atmae.state.newd;

/**
 * @Author: Mae
 * @Date: 2022/6/5
 * @Time: 15:47
 * @Description:
 */
public class ProfessionalState extends State {


    @Override
    public void handle(Context context) {
        if (context.score >= 800) {
            context.setState(new FinalState());
            context.request();

        } else {
            System.out.println("高手级别玩家 拥有changeCards方法");
        }
    }
}



package com.atmae.state.newd;

/**
 * @Author: Mae
 * @Date: 2022/6/5
 * @Time: 15:47
 * @Description:
 */
public class FinalState extends State {


    @Override
    public void handle(Context context) {
        System.out.println("骨灰级问玩家 peekCards功能");

    }
}

```
4、客户端
```java
package com.atmae.state.newd;

/**
 * @Author: Mae
 * @Date: 2022/6/5
 * @Time: 15:54
 * @Description:
 */
public class Client {
    public static void main(String[] args) {
        Context context = new Context();
        context.score=750;
        context.request();
    }
}

```
## 五、UML图
![在这里插入图片描述](https://img-blog.csdnimg.cn/a7cb3463573f446aa8901edc179134a6.png#pic_center)
## 六、状态模式适用场景
- 对象的行为依赖于他的状态并且可以根据它的状态改变而改变它的相关行为，具有不同状态时其行为有所差异。
- 代码中包含了大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户端类与类库之间地耦合增强。在这些条件语句中
包含了对象的行为，而且这些条件对应于对象的各种状态。

## 七、总结
### 优点
- 封装了转换原则。在状态模式中无须使用冗长的条件语句来进行判断和转移，将不同状态之间的转换封装在状态类中，提高了代码的可维护性。
- 枚举可能的状态，在枚举状态之前需要确定状态种类。
- 将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。
- 允许状态转换逻辑与状态对象合成一体，而不是一个巨大的条件语句块。
- 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数
### 缺点
- 状态模式的使用必然会增加系统类和对象的个数
- 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码混乱。
- 状态模式对“开放封闭原则”的支持并不友好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需要
 修改对应类的源代码
 ## 八、与其他模式的关系
 ### 状态模式与策略模式的比较：
 状态模式和策略模式有很大程度上的相似：它们都有一个Context类，都是通过委托（组合）给一个具有多个派生类的多态基类实现Context的算法逻辑
两者最大的差别就是State模式中派生类持有指向Context对象的引用，并通过这个引用调用Context中的方法，但在Strategy模式中就没有这种情况
