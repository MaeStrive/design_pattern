# 行为模式——观察者模式
# 本质：触发联动
## 一、定义
定义对象间的一种一对多的依赖关系，使得每当一个对象发生改变时，其相关依赖对象皆得到通知并被自动更新。又称发布-订阅模式、模型-视图模式、源-监听器模式
## 二、问题
某高校教学观系统需要实现如下功能，如果某个系得系名发生变化，则该系所有老师和学生得所属系名都需要发生改变。
## 三、解决方案
目标即为系名是否变化，观察者即为老师和学生。系拥有老师和学生的引用。
## 四、代码实现
1、目标(Subject)
目标又称为主题，它是指被观察到对象。在目标中定义一个观察者集合，他可以存储任意数量的观察者对象，他提供一个接口来增加和删除观察者对象，同时它定义了的通知方法notify()。
目标类可以是接口，也可以是抽象类，也可以是具体类。
```java
package com.atmae.observe.newd;

import java.util.ArrayList;
import java.util.List;

/**
 * @Author: Mae
 * @Date: 2022/6/5
 * @Time: 16:42
 * @Description:
 */
public abstract class Subject {
    protected List<Observer> observerList = new ArrayList<>();

    public abstract void attach(Observer observer);

    public abstract void detach(Observer observer);

    public abstract void notify0();
}

```
2、具体目标(ConcreteSubject)
具体目标是目标的子类，通常它包含经常发生改变的数据，当他的状态发生改变时，向它的各个观察者发出通知。同时它还实现了在目标类中定义的抽象业务逻辑方法(如果有的话)
```java
package com.atmae.observe.newd;

/**
 * @Author: Mae
 * @Date: 2022/6/5
 * @Time: 16:45
 * @Description:
 */
public class MySubject extends Subject {
    @Override
    public void attach(Observer observer) {
        observerList.add(observer);
    }

    @Override
    public void detach(Observer observer) {
        observerList.remove(observer);
    }

    @Override
    public void notify0() {
        for (Observer observer : observerList) {
            observer.update();
        }
    }
}

```
3、观察者(Observer)
观察者将对观察目标做出反应，观察者一般定义为接口，该接口声明了更新数据的方法update(),因此又称为抽象观察者。
```java
package com.atmae.observe.newd;

/**
 * @Author: Mae
 * @Date: 2022/6/5
 * @Time: 16:42
 * @Description:
 */
public interface Observer {

    public void update();
}

```
4、具体观察者(ConcreteObserver)
在具体观察者中维护一个指向具体目标对象的引用，他存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象管擦或者Observer中定义的update方法。通常在实现时，
可以调用具体目标类attach方法将自己添加到目标类的观察者集合中或通过detach方法将自己从目标类的观察者集合中删除.
```java
package com.atmae.observe.newd;

/**
 * @Author: Mae
 * @Date: 2022/6/5
 * @Time: 16:44
 * @Description:
 */
public class StudentObserver implements Observer{

    @Override
    public void update() {
        System.out.println("学生的所属系名发生变化");
    }
}



package com.atmae.observe.newd;

/**
 * @Author: Mae
 * @Date: 2022/6/5
 * @Time: 16:44
 * @Description:
 */
public class TeacherObserver implements Observer{

    @Override
    public void update() {
        System.out.println("老师的所属系名发生变化");
    }
}

```
5、客户端
```java
package com.atmae.observe.newd;

/**
 * @Author: Mae
 * @Date: 2022/6/5
 * @Time: 16:48
 * @Description:
 */
public class Client {
    public static void main(String[] args) {
        Observer observer = new StudentObserver();
        Observer observer2 = new TeacherObserver();
        Subject subject = new MySubject();
        subject.attach(observer);
        subject.attach(observer2);
        subject.notify0();
    }
}

```
## 五、UML图
![在这里插入图片描述](https://img-blog.csdnimg.cn/ff781103bfe0417d8f678762b8b94a3c.png#pic_center)

## 六、观察者模式使用场景
- 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使他们可以各自独立地改变和复用。
- 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象发生改变，可以降低对象之间的耦合度.
- 一个对象必须通知其他对象，而并不知道这些对象是谁。
- 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……可以使用观察者模式创建一种链式触发机制。
## 七、总结
### 优点
- 观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者的角色
- 观察者模式在观察目标和观察者之间建立一个抽象的耦合。观察目标只需要维持一个抽象观察者的结合，每一个具体观察者都符合抽象观察者的定义。观察目标不需要了解其具体观察者，只需要知道
 他们都有一个共同的接口即可。由于观察目标和观察者没有紧密地耦合在一起，因此他们可以属于不同的抽象化层次。
- 观察者模式支持广播通信，观察目标会向所有注册的观察者发出通知，简化了一对多系统设计的难度。
- 观察者符合开闭的要求，增加新的具体观察者无需修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便。
### 缺点
- 如果一个观察目标对象有很多直接和间接的观察者的话，将所有观察者都通知到会花费很多时间。
- 如果在观察者和观察者目标之间有循环依赖的话，观察目标会触发他们之间进行循环调用，可能导致系统崩溃。
- 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么变化的，而仅仅只是知道观察目标发生了变化
## 八、与其他模式的关系
