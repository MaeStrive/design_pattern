# 行为模式——模板方法模式
# 本质：固定算法骨架
## 一、定义
定义一个操作中算法的骨架，而一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤。
## 二、问题
模板方法模式实现数据库操作实例，数据库操作包括连接、打开、使用、关闭等。
## 三、解决方案
四个算法，一个方法定义四个算法的骨架。
## 四、代码实现
1、抽象类(AbstractClass)
在抽象类中定义一系列基本操作，这些基本操作可以是具体的，也可以是抽象的每一个基本操作对应算法的一个步骤，在其子类中可以冲定义并实现各个算法的步骤。同时在抽象类中实现了一个模板
方法，用于定义一个算法的骨架，此模板方法不仅可以调用基本操作，还可以调用在抽象类中声明在其子类中实现的抽象方法，当然也可以带有其他对象中的方法。
```java
package com.atmae.templateMethod.newd;

/**
 * @Author: Mae
 * @Date: 2022/6/13
 * @Time: 18:30
 * @Description:
 */
public abstract class DBOperator {
    abstract void connDB();

    abstract void openDB();

    abstract void useDB();

    void closeDB() {
        System.out.println("关闭数据库");
    }


    void templateMethod() {
        connDB();
        openDB();
        useDB();
        closeDB();
    }
}

```
2、具体子类(ConcreteClass)
具体子类是抽象类的子类，用于实现在父类中定义的抽象基本操作以完成子类特定算法的步骤，也可以覆盖在父类中实现的具体基本操作。
```java
package com.atmae.templateMethod.newd;

/**
 * @Author: Mae
 * @Date: 2022/6/13
 * @Time: 18:32
 * @Description:
 */
public class OracleDBOperator extends DBOperator {
    @Override
    void connDB() {
        System.out.println("Oracle连接数据库");
    }

    @Override
    void openDB() {
        System.out.println("Oracle打开数据库");
    }

    @Override
    void useDB() {
        System.out.println("Oracle使用数据库");
    }
}

```
```java
package com.atmae.templateMethod.newd;

/**
 * @Author: Mae
 * @Date: 2022/6/13
 * @Time: 18:32
 * @Description:
 */
public class SQLServerDBOperator extends DBOperator {
    @Override
    void connDB() {
        System.out.println("SQLServer连接数据库");
    }

    @Override
    void openDB() {
        System.out.println("SQLServer打开数据库");
    }

    @Override
    void useDB() {
        System.out.println("SQLServer使用数据库");
    }
}

```
3、客户端
```java
package com.atmae.templateMethod.newd;

/**
 * @Author: Mae
 * @Date: 2022/6/13
 * @Time: 18:34
 * @Description:
 */
public class Client {
    public static void main(String[] args) {
        DBOperator operator = new OracleDBOperator();
        operator.templateMethod();
    }
}

```
## 五、UML图
![在这里插入图片描述](https://img-blog.csdnimg.cn/e632f4c907e7433d8e2e802d98c21290.png#pic_center)

## 六、模板方法模式使用场景
- 一次性实现一个算法的不变部分，并将可变行为留给子类来实现。
- 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。首先需要识别现有代码中的不同之处，并且将不同之处出分离为新的操作；然后，用一个调用这些新的操作的模板方
法来替换这些不同的代码。
- 对一些复杂的算法进行分隔，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现。
- 控制子类的扩展，模板方法只在特定点调用钩子方法，这样就只允许在这些点进行扩展，也就是说对应某些方法，可以通过钩子方法来进行扩展，而对于不能进行扩展的方法可以将其定义为
final方法，对算法的扩展进行有效地控制和约束
## 七、总结
### 优点
- 模板方法模式在一个类中形式化的定义算法，而由它的子类实现细节的处理。模板方法模式的优势是在子类定义详细的处理算法时不会改变算法的结构。
- 模板方法时一种代码复用的基本你技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为。
- 模板方法模板提供了一种反向的控制结构，通过一个父类调用其子类的操作，通过子类的扩展增加新的行为，符合”开闭原则”。
### 缺点
- 每个不同的实现都需要定义一个子类，这将导致类的个数增加，系统更加庞大，设计也更加抽象，但是更加符合“单一职责原则“，使得类的内聚性得以提高。
## 八、模板方法模式与其他模式的关系
