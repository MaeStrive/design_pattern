# 行为模式——中介者模式
# 本质：封装交互
## 一、定义
用一个中介对象来封装一系列对象的交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立的改变他们之间的交互。
## 二、问题
使用中介者模式说明联合国的作用；联合国定义为抽象中介者类，联合国下属机构WTO WFC WHO等作为具体中介者，国家作为抽象同事类，中国、美国、英国则为具体同事类。
## 三、解决方案
题目说的很清楚了；实现就行了
## 四、代码实现
1、抽象中介者(Mediator)
抽象中介者用于定义一个接口，该接口用于各同事对象之间的通信
```java
package com.atmae.mediator;

/**
 * @Author: Mae
 * @Date: 2022/6/7
 * @Time: 10:40
 * @Description:
 */
public abstract class UnitedNation {

    public abstract void connection(String msg, Nation nation);
}

```
2、具体中介者(ConcreteMediator)
具体中介者是抽象中介者的子类，通过协调各个同事对象来实现协作行为，了解并维护他对各个同时对象的引用。具体中介者和各个具体同事类之间有关联关系，在实现时为了保证系统的扩展性，可以根据需要将该引用关联关系建立在抽象层，即具体中介者中定义的是抽象同时角色。
```java
package com.atmae.mediator;

/**
 * @Author: Mae
 * @Date: 2022/6/7
 * @Time: 10:46
 * @Description:
 */
public class WHO extends UnitedNation {
    private Nation america;
    private Nation britain;
    private Nation china;




    public void setAmerica(Nation america) {
        this.america = america;
    }

    public void setBritain(Nation britain) {
        this.britain = britain;
    }

    public void setChina(Nation china) {
        this.china = china;
    }

    @Override
    public void connection(String msg, Nation nation) {
        System.out.println(this.getName()+"传递消息：");
        if (nation==america) {
            america.exchange(msg);
        } else if (nation==britain) {
            britain.exchange(msg);
        } else {
            china.exchange(msg);
        }
    }
}



package com.atmae.mediator;

/**
 * @Author: Mae
 * @Date: 2022/6/7
 * @Time: 10:42
 * @Description:
 */
public class WTO extends UnitedNation {


    private Nation america;
    private Nation britain;
    private Nation china;


    public void setAmerica(Nation america) {
        this.america = america;
    }

    public void setBritain(Nation britain) {
        this.britain = britain;
    }

    public void setChina(Nation china) {
        this.china = china;
    }

    @Override
    public void connection(String msg, Nation nation) {
        System.out.println(this.getName() + "传递消息：");
        if (nation==america) {
            america.exchange(msg);
        } else if (nation==britain) {
            britain.exchange(msg);
        } else {
            china.exchange(msg);
        }
    }
}

```

3、抽象同事类(Colleague)
抽象同事类定义各同事的共有方法。
```java
package com.atmae.mediator;

/**
 * @Author: Mae
 * @Date: 2022/6/7
 * @Time: 10:42
 * @Description:
 */
public abstract class Nation {

    protected UnitedNation unitedNation;


    public Nation(UnitedNation unitedNation) {
        this.unitedNation = unitedNation;
    }

    public abstract void notify(String msg,Nation nation);
    public abstract void exchange(String msg);
}

```

4、具体同事类(ConcreteColleague)
具体同事类是抽象同事类的子类，每一个同事对象都引用一个中介者对象；每一个同事对象在需要和其他同事对象通信时，先于中介者通信，通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中声明的抽象方法。
```java
package com.atmae.mediator;

/**
 * @Author: Mae
 * @Date: 2022/6/7
 * @Time: 10:46
 * @Description:
 */
public class America extends Nation{



    public America(UnitedNation unitedNation) {
        super(unitedNation);
    }

    @Override
    public void notify(String msg, Nation nation) {
        System.out.println("America 发送消息给");
        this.unitedNation.connection(msg, nation);
    }
    @Override
    public void exchange(String msg) {
        System.out.println("America 收到消息："+msg);
    }



}



package com.atmae.mediator;

/**
 * @Author: Mae
 * @Date: 2022/6/7
 * @Time: 10:45
 * @Description:
 */
public class Britain extends Nation{



    public Britain(UnitedNation unitedNation) {
        super(unitedNation);
    }

    @Override
    public void notify(String msg, Nation nation) {
        System.out.println("Britain 发送消息给");
        this.unitedNation.connection(msg, nation);
    }


    @Override
    public void exchange(String msg) {
        System.out.println("Britain 收到消息："+msg);
    }
}





package com.atmae.mediator;

/**
 * @Author: Mae
 * @Date: 2022/6/7
 * @Time: 10:45
 * @Description:
 */
public class China extends Nation {


    public China(UnitedNation unitedNation) {
        super(unitedNation);
    }

    @Override
    public void notify(String msg, Nation nation) {
        System.out.println("China 发送消息给");
        this.unitedNation.connection(msg, nation);
    }


    @Override
    public void exchange(String msg) {
        System.out.println("China 收到消息" + msg);
    }
}

```
## 五、UML图
![在这里插入图片描述](https://img-blog.csdnimg.cn/9ffa99183d404402a8c15c8fe6c30815.png#pic_center)
## 六、中介者模式适用场景
## 七、总结
### 优点
### 缺点
## 八、中介者模式与其他模式的关系
- 外观模式和中介者模式的区别

外观(Facade)模式和中介者(Mediator)模式有着共同的目的。它们都是调配一组相互耦合的对象的通信。不过外观模式关注的是这组复杂对象如何与外界通信，而中介者模式是调配这组复杂对象之间的通信(模块内部)。

- 中介者模式和观察者模式

可以组合使用，来实现当同事对象发生改变的时候，通知中介对象，让中介对象去进行与其他相关对象的交互
