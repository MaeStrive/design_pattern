# 行为模式——中介者模式
# 本质：封装交互
## 一、定义
用一个中介对象来封装一系列对象的交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立的改变他们之间的交互。
## 二、问题
使用中介者模式说明联合国的作用；联合国定义为抽象中介者类，联合国下属机构WTO WFC WHO等作为具体中介者，国家作为抽象同事类，中国、美国、英国则为具体同事类。
## 三、解决方案
题目说的很清楚了；实现就行了
## 四、代码实现
1、抽象中介者(Mediator)
抽象中介者用于定义一个接口，该接口用于各同事对象之间的通信
```java
package com.atmae.mediator;

/**
 * @Author: Mae
 * @Date: 2022/6/7
 * @Time: 10:40
 * @Description:
 */
public abstract class UnitedNation {

    public abstract void connection(String msg, Nation nation);
}

```
2、具体中介者(ConcreteMediator)
具体中介者是抽象中介者的子类，通过协调各个同事对象来实现协作行为，了解并维护他对各个同时对象的引用。具体中介者和各个具体同事类之间有关联关系，在实现时为了保证系统的扩展性，可以根据需要将该引用关联关系建立在抽象层，即具体中介者中定义的是抽象同时角色。
```java
package com.atmae.mediator;

/**
 * @Author: Mae
 * @Date: 2022/6/7
 * @Time: 10:46
 * @Description:
 */
public class WHO extends UnitedNation {
    private Nation america;
    private Nation britain;
    private Nation china;




    public void setAmerica(Nation america) {
        this.america = america;
    }

    public void setBritain(Nation britain) {
        this.britain = britain;
    }

    public void setChina(Nation china) {
        this.china = china;
    }

    @Override
    public void connection(String msg, Nation nation) {
        System.out.println(this.getName()+"传递消息：");
        if (nation==america) {
            america.exchange(msg);
        } else if (nation==britain) {
            britain.exchange(msg);
        } else {
            china.exchange(msg);
        }
    }
}



package com.atmae.mediator;

/**
 * @Author: Mae
 * @Date: 2022/6/7
 * @Time: 10:42
 * @Description:
 */
public class WTO extends UnitedNation {


    private Nation america;
    private Nation britain;
    private Nation china;


    public void setAmerica(Nation america) {
        this.america = america;
    }

    public void setBritain(Nation britain) {
        this.britain = britain;
    }

    public void setChina(Nation china) {
        this.china = china;
    }

    @Override
    public void connection(String msg, Nation nation) {
        System.out.println(this.getName() + "传递消息：");
        if (nation==america) {
            america.exchange(msg);
        } else if (nation==britain) {
            britain.exchange(msg);
        } else {
            china.exchange(msg);
        }
    }
}

```

3、抽象同事类(Colleague)
抽象同事类定义各同事的共有方法。
```java
package com.atmae.mediator;

/**
 * @Author: Mae
 * @Date: 2022/6/7
 * @Time: 10:42
 * @Description:
 */
public abstract class Nation {

    protected UnitedNation unitedNation;


    public Nation(UnitedNation unitedNation) {
        this.unitedNation = unitedNation;
    }

    public abstract void notify(String msg,Nation nation);
    public abstract void exchange(String msg);
}

```

4、具体同事类(ConcreteColleague)
具体同事类是抽象同事类的子类，每一个同事对象都引用一个中介者对象；每一个同事对象在需要和其他同事对象通信时，先于中介者通信，通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中声明的抽象方法。
```java
package com.atmae.mediator;

/**
 * @Author: Mae
 * @Date: 2022/6/7
 * @Time: 10:46
 * @Description:
 */
public class America extends Nation{



    public America(UnitedNation unitedNation) {
        super(unitedNation);
    }

    @Override
    public void notify(String msg, Nation nation) {
        System.out.println("America 发送消息给");
        this.unitedNation.connection(msg, nation);
    }
    @Override
    public void exchange(String msg) {
        System.out.println("America 收到消息："+msg);
    }



}



package com.atmae.mediator;

/**
 * @Author: Mae
 * @Date: 2022/6/7
 * @Time: 10:45
 * @Description:
 */
public class Britain extends Nation{



    public Britain(UnitedNation unitedNation) {
        super(unitedNation);
    }

    @Override
    public void notify(String msg, Nation nation) {
        System.out.println("Britain 发送消息给");
        this.unitedNation.connection(msg, nation);
    }


    @Override
    public void exchange(String msg) {
        System.out.println("Britain 收到消息："+msg);
    }
}





package com.atmae.mediator;

/**
 * @Author: Mae
 * @Date: 2022/6/7
 * @Time: 10:45
 * @Description:
 */
public class China extends Nation {


    public China(UnitedNation unitedNation) {
        super(unitedNation);
    }

    @Override
    public void notify(String msg, Nation nation) {
        System.out.println("China 发送消息给");
        this.unitedNation.connection(msg, nation);
    }


    @Override
    public void exchange(String msg) {
        System.out.println("China 收到消息" + msg);
    }
}

```
## 五、UML图
![在这里插入图片描述](https://img-blog.csdnimg.cn/9ffa99183d404402a8c15c8fe6c30815.png#pic_center)
## 六、中介者模式适用场景
- 系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解。
- 一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象。
- 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象交互的公共行为，如果需要改变行为则可以增加新的中介者类。
## 七、总结
### 优点
- 简化了对象之间的交互。用中介者和同事的一对多交互代替了原来同事之间多对多的交互，一对多关系更容易理解、维护和扩展，将原本难以理解的网状结构转换成相对简单的星状结构。
- 将各同事解耦。中介者有利于各同事之间的松耦合，我们可以独立的改变和复用各同事和中介者，增加新的中介者和新的同事类都比较方便，更好地符合”开闭原则“。
- 减少子类生成。中介者将原本分布于多个对象间的行为集中在一起，改变这些行为只需生成新的中介者子类即可，这使各个同事类可被重用，无需对同事类进行扩展。
- 对于复杂的对象之间交互。通过引入中介者，可以简化各同事类的设计和实现，但是当情况复杂时，中介者可能就会变得很复杂和难以维护，这时可以对中介者进行再分解，使其只对一种类型的同事适用，这样在中介者类中就不必包括很多的if……else if等语句，同时当新增加一种同事时，可以通过创建与该同事类对应的中介者类，而对于其他同事的中介者类影响较小，从而便于维护和扩展。
### 缺点
- 在具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。
## 八、中介者模式与其他模式的关系
- 外观模式和中介者模式的区别

外观(Facade)模式和中介者(Mediator)模式有着共同的目的。它们都是调配一组相互耦合的对象的通信。不过外观模式关注的是这组复杂对象如何与外界通信，而中介者模式是调配这组复杂对象之间的通信(模块内部)。

- 中介者模式和观察者模式

可以组合使用，来实现当同事对象发生改变的时候，通知中介对象，让中介对象去进行与其他相关对象的交互
