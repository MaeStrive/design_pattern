# 行为模式——备忘录模式
# 本质：保存和恢复内部状态
## 一、定义
在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。
## 二、问题
实现用户撤销功能(注意：可以撤销多次哦😊)
## 三、解决方案
就三个类。原发器，备忘录，发起人。嘿嘿🤭
## 四、代码实现
1、原发器(Originator)
原发器可以创建一个备忘录，并存储它的当前内部状态，也可以使用备忘录来恢复其内部状态。一般将需要保存内部状态的类设计为原发起，如一个存储用户信息或商品信息的对象。
```java
package com.atmae.momento.new1;

/**
 * @Author: Mae
 * @Date: 2022/6/4
 * @Time: 10:36
 * @Description:
 */
public class Originator {
    private String state;

    public Originator(String state) {
        this.state = state;
    }

    public void setState(String state) {
        this.state = state;
    }

    public Memento createMemento() {
        return new Memento(this.state);
    }

    public String getState() {
        return this.state;
    }

    public void restoreMemento(Memento m) {
        this.state = m.getState();
    }
}

```
2、备忘录(Memento)
存储原发器的内部状态，根据原发器来决定保存哪些内部状态。备忘录的设计一般可以参考原发器的设计，根据实际需要确定备忘录类中的属性。注意：除了原发器本身与负责人类之外，
备忘录对象不能直接拱其他类使用，因此备忘录的设计在不同的编程语言中实现的机制有所区别.
```java
package com.atmae.momento.new1;

/**
 * @Author: Mae
 * @Date: 2022/6/4
 * @Time: 10:36
 * @Description:
 */
public class Memento {
    private String state;


    public Memento(String state) {
        this.state = state();
    }


    public void setState(String state) {
        this.state = state;
    }

    public String getState() {
        return this.state;
    }
}


```
3、负责人(Caretaker)
负责人又称管理者，她负责保存备忘录，但是不能对备忘录的内容进行操作或检查。在负责人类中可以存储一个或多个备忘录对象，它只负责存储对象，而不能修改对象，也无需知道对象的实现细节。
```java
package com.atmae.momento.new1;

import java.util.ArrayList;
import java.util.List;

/**
 * @Author: Mae
 * @Date: 2022/6/4
 * @Time: 10:36
 * @Description:
 */
public class Caretaker {
    private List<Memento> mementos=new ArrayList<>();

    public Memento getMemento() {
        if (mementos.isEmpty()) {
            try {
                throw new Exception("当前您没有保存，无法撤销");
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        Memento memento = mementos.get(mementos.size() - 1);
        mementos.remove(memento);
        return memento;
    }

    public void setMemento(Memento memento) {
        if (mementos.size() >= 5) {
            try {
                throw new Exception("您保存撤销不能大于五次!");
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        mementos.add(memento);
    }
}

```
4、客户端
```java
package com.atmae.momento.new1;

/**
 * @Author: Mae
 * @Date: 2022/6/4
 * @Time: 10:44
 * @Description:
 */
public class Client {
    public static void main(String[] args) {
        Caretaker caretaker = new Caretaker();
        Originator originator = new Originator("你好");
        //存档
        caretaker.setMemento(originator.createMemento());
        System.out.println(originator.getState());
        originator.setState("Hello World!");
        System.out.println(originator.getState());
        //恢复
        originator.restoreMemento(caretaker.getMemento());
        System.out.println(originator.getState());
    }
}
```
## 五、UML图
![在这里插入图片描述](https://img-blog.csdnimg.cn/300057a883984bd7a9bb4b815fb5b3c7.png#pic_center)

## 六、备忘录模式适用场景
- 保存一个对象在某一个时刻的状态或部分状态，这样以后需要时它能够恢复到先前的状态
- 如果用一个接口来让其他对象得到这些状态，将会暴露对象的实现细节并破坏对象的封装性，一个对象不希望外界直接访问其内部状态，通过负责人可以间接访问其内部状态。
## 七、总结
### 优点
- 提供了一种恢复的实现机制，使得用户可以方便地回到一个特定地历史步骤，当新的状态无效或者存在问题时，可以使用先去存储地备忘录将状态复原
- 实现了信息的封装，一个备忘录对象是一种原发器对象的表示，不会被其他代码改动，简化了原发器对象，备忘录只保存原发器的状态，采用堆栈来存储备忘录对象可以实现多次撤销操作，
 可以通过在负责人中定义集合对象来存储多个备忘录
### 缺点
- 资源消耗过大，如果类的成员变量太多，就不可避免占用大量的内存，而且每保存一次对象的状态都需要消耗内存资源，如果知道这一点大家就容易理解为什么提供撤销功能的软件在运行时所需的内存和硬盘空间比较大了
## 八、与其他模式的关系
- 备忘录模式和原型模式
 这两个模式可以组合使用.
在原发器对象（发起人对象）创建备忘录对象的时候，如果原发器对象中全部或者大部分的状态都需要保存，一个简洁的方式就是直接克隆一个原发器对象。也就是说，这个时候备忘录对象里面存放的是一个原发器对象的实例。
