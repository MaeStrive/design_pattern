# 行为模式——备忘录模式
# 本质：保存和恢复内部状态
## 一、定义
在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。
## 二、问题
## 三、解决方案
## 四、代码实现
1、原发器(Originator)
原发器可以创建一个备忘录，并存储它的当前内部状态，也可以使用备忘录来恢复其内部状态。一般将需要保存内部状态的类设计为原发起，如一个存储用户信息或商品信息的对象。
```java
package com.atmae.momento.new1;

/**
 * @Author: Mae
 * @Date: 2022/6/4
 * @Time: 10:36
 * @Description:
 */
public class Originator {
    private String state;

    public Originator(String state) {
        this.state = state;
    }

    public void setState(String state) {
        this.state = state;
    }

    public Memento createMemento() {
        return new Memento(this);
    }

    public String getState() {
        return this.state;
    }

    public void restoreMemento(Memento m) {
        this.state = m.getState();
    }
}

```
2、备忘录(Memento)
存储原发器的内部状态，根据原发器来决定保存哪些内部状态。备忘录的设计一般可以参考原发器的设计，根据实际需要确定备忘录类中的属性。注意：除了原发器本身与负责人类之外，
备忘录对象不能直接拱其他类使用，因此备忘录的设计在不同的编程语言中实现的机制有所区别.
```java
package com.atmae.momento.new1;

/**
 * @Author: Mae
 * @Date: 2022/6/4
 * @Time: 10:36
 * @Description:
 */
public class Memento {
    private String state;


    public Memento(Originator o) {
        this.state = o.getState();
    }


    public void setState(String state) {
        this.state = state;
    }

    public String getState() {
        return this.state;
    }
}


```
3、负责人(Caretaker)
负责人又称管理者，她负责保存备忘录，但是不能对备忘录的内容进行操作或检查。在负责人类中可以存储一个或多个备忘录对象，它只负责存储对象，而不能修改对象，也无需知道对象的实现细节。
```java
package com.atmae.momento.new1;

import java.util.ArrayList;
import java.util.List;

/**
 * @Author: Mae
 * @Date: 2022/6/4
 * @Time: 10:36
 * @Description:
 */
public class Caretaker {
    private List<Memento> mementos=new ArrayList<>();

    public Memento getMemento() {
        if (mementos.isEmpty()) {
            try {
                throw new Exception("当前您没有保存，无法撤销");
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        Memento memento = mementos.get(mementos.size() - 1);
        mementos.remove(memento);
        return memento;
    }

    public void setMemento(Memento memento) {
        if (mementos.size() >= 5) {
            try {
                throw new Exception("您保存撤销不能大于五次!");
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        mementos.add(memento);
    }
}

```
4、客户端
```java
package com.atmae.momento.new1;

/**
 * @Author: Mae
 * @Date: 2022/6/4
 * @Time: 10:44
 * @Description:
 */
public class Client {
    public static void main(String[] args) {
        Caretaker caretaker = new Caretaker();
        Originator originator = new Originator("你好");
        //存档
        caretaker.setMemento(originator.createMemento());
        System.out.println(originator.getState());
        originator.setState("Hello World!");
        System.out.println(originator.getState());
        //恢复
        originator.restoreMemento(caretaker.getMemento());
        System.out.println(originator.getState());
    }
}
```
## 五、UML图
## 六、备忘录模式适用场景
## 七、总结
### 优点
### 缺点
