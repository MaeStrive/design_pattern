# 行为模式——访问者模式
# 本质：预留通路，回调实现
## 一、定义
表示一个作用于某对象结构中的各元素的操作，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
## 二、问题
实现教师奖励和学生奖励的审批，如果教师发表论文数超过10篇或者学生论文超过2篇可以评选科研奖。如果教师教学反馈分大于等于90或者学生平均成绩超过90可以评选成绩优秀
奖，使用访问者模式实现啦。
## 三、解决方案
科研奖和成绩优秀奖可以是两个具体访问者，他们实现自抽象访问者。学生和教师是具体元素，他们实现自抽象元素。
## 四、代码实现
1、抽象访问者(Vistor)
抽象访问者为对象结构中每一个具体元素类ConcreteElement声明一个访问操作，从这个操作的名称或参数类型可以清楚知道需要访问的具体元素的类型，具体访问者需要实现这些方法，定义对这
些元素的访问操作。
```java
package com.atmae.visitor;

/**
 * @Author: Mae
 * @Date: 2022/6/13
 * @Time: 19:34
 * @Description:
 */
public abstract class AwardCheck {
    abstract void visitTeacher(Teacher teacher);
    abstract void  visitStudent(Student student);
}

```
2、具体访问者(ConcreteVisitor)
具体访问者实现了每个由抽象访问者声明的操作，每一个操作用于访问对象结构中一种类型的元素。
```java
package com.atmae.visitor;

/**
 * @Author: Mae
 * @Date: 2022/6/13
 * @Time: 19:35
 * @Description:
 */
public class ExcellenceAwardCheck extends AwardCheck {
    @Override
    void visitTeacher(Teacher teacher) {
        if (teacher.feedbackScore >= 90) {
            System.out.println("教师评选为成绩优秀奖");
        }else {
            System.out.println("教师未被评选为成绩优秀奖");
        }
    }

    @Override
    void visitStudent(Student student) {
        if (student.score >= 90) {
            System.out.println("学生评选为成绩优秀奖");
        }else{
            System.out.println("学生未被评选为成绩优秀奖");
        }
    }
}

```
```java
package com.atmae.visitor;

/**
 * @Author: Mae
 * @Date: 2022/6/13
 * @Time: 19:35
 * @Description:
 */
public class ScientificAwardCheck extends AwardCheck{
    @Override
    void visitTeacher(Teacher teacher) {
        if(teacher.paperCount>=10){
            System.out.println("教师评选为科研奖");
        }else {
            System.out.println("教师未被评选科研奖");
        }
    }

    @Override
    void visitStudent(Student student) {
        if (student.paperCount>=2){
            System.out.println("学生评选为科研奖");
        }else{
            System.out.println("学生未被评选为科研奖");
        }
    }
}

```
3、抽象元素(Element)
抽象元素一般是抽象类或者接口，它定义一个accept()方法，该方法以一个抽象访问者作为参数。
```java
package com.atmae.visitor;

/**
 * @Author: Mae
 * @Date: 2022/6/13
 * @Time: 19:36
 * @Description:
 */
public interface Person {
    void accept(AwardCheck awardCheck);
}

```
4、具体元素(ConcreElement)
具体元素实现了accept()方法，在其accept()中调用访问者的访问方法以便完成对一个元素的操作。
```java
package com.atmae.visitor;

/**
 * @Author: Mae
 * @Date: 2022/6/13
 * @Time: 19:36
 * @Description:
 */
public class Student implements Person {
   private int paperCount;
   private double score;

    public Student(int paperCount, double score) {
        this.paperCount = paperCount;
        this.score = score;
    }

    @Override
    public void accept(AwardCheck awardCheck) {
        awardCheck.visitStudent(this);
    }
}

```
```java
package com.atmae.visitor;

/**
 * @Author: Mae
 * @Date: 2022/6/13
 * @Time: 19:36
 * @Description:
 */
public class Teacher implements Person {
    private int paperCount;
    private double feedbackScore;

    public Teacher(int paperCount, double feedbackScore) {
        this.paperCount = paperCount;
        this.feedbackScore = feedbackScore;
    }

    @Override
    public void accept(AwardCheck awardCheck) {
        awardCheck.visitTeacher(this);
    }
}

```
5、对象结构(ObjectStructure)
对象结构是一个元素的集合，它用于存放元素对象，并且提供了遍历其内部元素的方法。它可以结合组合模式来实现，也可以是一个简单的集合对象，如一个List对象或一个Set对象
```java
package com.atmae.visitor;

import java.util.ArrayList;
import java.util.List;

/**
 * @Author: Mae
 * @Date: 2022/6/13
 * @Time: 19:39
 * @Description:
 */
public class CandidateList {
    private List<Person> personList = new ArrayList<>();

    public void accept(AwardCheck awardCheck) {
        for (Person p :
                personList) {
            p.accept(awardCheck);
        }
    }

    public void addPerson(Person person) {
        personList.add(person);
    }

    public void removePerson(Person person) {
        personList.remove(person);
    }
}

```
6、客户端
```java
package com.atmae.visitor;

/**
 * @Author: Mae
 * @Date: 2022/6/13
 * @Time: 19:42
 * @Description:
 */
public class Client {
    public static void main(String[] args) {
        Person person = new Student(2, 95.6);
        Person person1 = new Student(0, 91.9);
        Person person2 = new Teacher(19, 60.7);
        CandidateList candidateList = new CandidateList();
        candidateList.addPerson(person);
        candidateList.addPerson(person1);
        candidateList.addPerson(person2);
        candidateList.accept(new ScientificAwardCheck());
    }
}

```
## 五、UML图
![在这里插入图片描述](https://img-blog.csdnimg.cn/904f47ba8fe04ac1abdd68dd3b719b7d.png#pic_center)

## 六、访问者模式适用场景
- 一个对象结构包含很多类型的对象，希望对这些对象实施一些依赖其具体类型的操作。在访问者中针对每一种具体的类型都提供了一个访问操作，不同类型的对象可以有不同的访问操作。
- 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。访问者模式使得我们可以将相关的访问操作
集中起来定于在访问者类中，对象结构可以被多个不同的访问者类所使用，将对象本身与对象的访问操作分离。
- 对象结构中对象对应的类很少变化，但经常需要在此对象结构上定义新的操作。**对访问操作符合”开闭原则“，对对象元素不符合“开闭原则”**。
## 七、总结
### 优点
- 使得增加新的访问操作变得容易。使用访问者模式，增加新的访问操作就意味着增加一个新的访问者类，无需修改现有的类库代码，符合“开放封闭原则”。
- 将有关元素对象的访问行为集中到一个访问者对象中，而不是分散到一个个的元素类中。类的职责更加清晰，有利于对象结构中元素对象的复用，相同的对象结构可以共多个不同的访问者访问。
- 可以跨越类的等级结构访问属于不同等级结构的元素类。
- 让用户能够在不修改现有类层次结构的情况下，定义该类层次的结构的新操作。
### 缺点
- 增加新的元素类很困难。在访问者模式中，每增加一个新的元素类都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作，违背了“开闭原则”
的要求。
- 破环封装。访问者模式要求访问者对象访问并调用每一个元素对象的操作，这意味着元素对象有时候暴露一些自己的内部操作和内部状态，否则无法供访问者访问。
## 八、访问者与其他模式的关系
### 访问者与组合模式
在访问者模式中，元素对象可能存在容器对象和叶子对象，因此可以结合组合模式来进行设计。
