# 行为模式——职责链模式
# 本质：分离职责，动态组合
## 一、定义
为解除请求的发送请求者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。
## 二、问题
某物资管理系统中物资采购需要分级审批，主任可以审批1万元及以下的采购单，部门经理可以审批5万元及以下的审批单，副总经理可以审批10万元及以下的审批单，
总经理可以审批20万元及以下的审批单，20万元以上的审批单需要开会决定。使用职责链模式设计该系统
## 三、解决方案
主任、部门经理、副总经理、总经理都是具体处理者，他们都继承自一个抽象处理者。完了！
## 四、代码实现
1、抽象处理者(Handler)
抽象处理者定义了一个处理请求的接口，它一般设计为抽象类，由于不同的具体处理者请求的方式不同，因此在其中定义了抽象请求处理方法。因为每一个处理者的下家还是一个处理者，
因此在抽象处理者中定义一个自类型（抽象处理者类型）的对象，作为其对下家的引用。通过该引用，处理者可以连成一条链。

```java
package com.atmae.chainofResponsibility;

/**
 * @Author: Mae
 * @Date: 2022/6/3
 * @Time: 19:18
 * @Description:
 */
public abstract class Handler {
    protected Handler successor;

    public void setHandler(Handler successor) {
        this.successor = successor;
    }

    public abstract void handlerRequest(Integer day);

}
```
2、具体处理者(ConcreteHandler)
具体处理者是抽象处理者的子类，它可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中的下一个对象，以便请求的转发。
```java
package com.atmae.chainofResponsibility;

/**
 * @Author: Mae
 * @Date: 2022/6/3
 * @Time: 19:19
 * @Description:
 */
public class DepartmentManager extends Handler {
    @Override
    public void handlerRequest(Integer day) {
        if (day <= 50000) {
            System.out.println("部门经理审批了这条采购单");
        } else {
            successor.handlerRequest(day);
        }
    }
}

```
```java
package com.atmae.chainofResponsibility;

/**
 * @Author: Mae
 * @Date: 2022/6/3
 * @Time: 19:19
 * @Description:
 */
public class Director extends Handler {
    @Override
    public void handlerRequest(Integer day) {
        if (day <= 10000) {
            System.out.println("主任审批了这条采购单");
        } else {
            successor.handlerRequest(day);
        }
    }
}

```
```java
package com.atmae.chainofResponsibility;

/**
 * @Author: Mae
 * @Date: 2022/6/3
 * @Time: 19:20
 * @Description:
 */
public class GeneralManager extends Handler {

    @Override
    public void handlerRequest(Integer day) {
        if (day <= 200000) {
            System.out.println("总经理审批了这条采购单");
        } else {
            System.out.println("大于20万了！开会决定吧！！！");
        }
    }
}

```
```java
package com.atmae.chainofResponsibility;

/**
 * @Author: Mae
 * @Date: 2022/6/3
 * @Time: 19:29
 * @Description:
 */
public class ViceGeneralManager extends Handler {
    @Override
    public void handlerRequest(Integer day) {
        if (day <= 100000) {
            System.out.println("副总经理审批了这条采购单");
        } else {
            successor.handlerRequest(day);
        }
    }
}

```
## 五、UML图
![在这里插入图片描述](https://img-blog.csdnimg.cn/c43bff53f1bd4da2824976c39ba029bb.png#pic_center)
## 六、职责链模式适用场景
- 有多个对象可以处理同一请求，具体哪个对象处理该请求由运行时刻自动确定。客户端只需要将请求提交到链上，无须关心请求的处理对象是谁以及它是如何处理的。
- 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。请求的发送者与请求的处理解耦，请求将沿着链进行传递，寻求相应的处理者。
- 可以动态指定一组对象处理请求。客户端可以动态创建职责链来处理请求，还可以动态改变链最终处理的先后顺序
## 七、总结
### 优点
- 降低耦合度：职责链使得一个对象无需知道是其他哪一个对象处理其请求。对象仅需直到该请求会被处理即可，接收者和发送者都没有对方的明确消息，且链中的对象不需要知道链中的结构，由客户端负责链的创建
- 可简化对象的相互连接：请求处理仅需维持一个指向其后继者的引用，而不需要维持他对所有候选处理者的引用。
- 增强给对象指派职责的灵活性：再给对象分派职责时，职责链可以给我们带来更多的灵活性。可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责。
- 增加新的请求处理类很方便：在系统中增加一个新的具体请求处理者无需改变原有系统的代码，只需要在客户端重新建链即可，从这一点来看是符合“开闭原则”的。
### 缺点
- 不能保证请求一定被接收：既然一个请求没有明确的接收者，那么就不能保证她一定会被处理，该请求可能一直到链的末端也不会被处理；一个请求也可能因职责链没有被正确配置而得不到处理。
- 对于比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响，而且在进行diamagnetic调试时不太方便；如果建链不当，可能会造成循环调用，将导致系统陷入死循环。
## 八、与其他模式的关系
- 与状态模式的关系
  - 状态模式是一个对象的内在状态发生改变，一个对象，相对比较稳定，处理完一个对象下一个对象的处理一般都已确定。在某个状态中已经确定了下一个状态（写死了，如果- 需要修改，需要打开每个类，进行修改，不符合开放封闭）
  - 职责链模式过于灵活，在客户端使用时，需要环境去确定下一个对象是谁，进行一系列的set操作……。职责链模式是多个对象之间的改变，就会出现某个对象不存在的情景。
